import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as c,c as l,a as e,b as n,d as t,e as s}from"./app-8d307529.js";const r={},p=s('<h2 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言" aria-hidden="true">#</a> 1.前言</h2><p>大家好，我是Leo哥🫣🫣🫣，上一节我们简单回顾了一下关于Servlet原生过滤器以及简单认识了SpringSecurity中的一些过滤器。但是底层SpringSecurity是如何维护这些过滤器，并通过这些过滤器是如果拦截我们的客户端请求的，我们都还只是停留在表层，今天就让我们去深入了解一下我们今天得主角---<strong>委派筛选器代理 DelegatingFilterProxy</strong>。好了，话不多说让我们开始吧😎😎😎。</p><h2 id="_2-剖析delegatingfilterproxy" tabindex="-1"><a class="header-anchor" href="#_2-剖析delegatingfilterproxy" aria-hidden="true">#</a> 2.剖析DelegatingFilterProxy</h2><h3 id="_2-1delegatingfilterproxy概述" tabindex="-1"><a class="header-anchor" href="#_2-1delegatingfilterproxy概述" aria-hidden="true">#</a> 2.1DelegatingFilterProxy概述</h3>',4),d={href:"https://docs.spring.io/spring-framework/docs/6.1.0-M2/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html",target:"_blank",rel:"noopener noreferrer"},u=e("code",null,"DelegatingFilterProxy",-1),g=e("code",null,"Filter",-1),k=e("code",null,"ApplicationContext",-1),h=e("code",null,"Filter",-1),m=e("code",null,"DelegatingFilterProxy",-1),y=e("code",null,"Filter",-1),f=e("strong",null,"SpringBean",-1),v=s(`<figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311071954680.png" alt="image-20231107195435608" tabindex="0" loading="lazy"><figcaption>image-20231107195435608</figcaption></figure><p>简单来说，<strong>DelegatingFilterProxy</strong>就是一个对于<code>servlet filter</code>的代理，用这个类的好处主要是通过Spring容器来管理servlet filter的生命周期，</p><ul><li>还有就是如果filter中需要一些Spring容器的实例，可以通过spring直接注入，</li><li>另外读取一些配置文件这些便利的操作都可以通过Spring来配置实现。</li></ul><blockquote><p>本质上来说DelegatingFilterProxy就是一个Filter，其间接实现了Filter接口，但是 <strong>在doFilter中其实调用的从Spring 容器中获取到的代理Filter的实现类delegate。</strong></p></blockquote><h3 id="_2-类的结构" tabindex="-1"><a class="header-anchor" href="#_2-类的结构" aria-hidden="true">#</a> 2.类的结构</h3><p>先看下 <code>DelegatingFilterProxy</code> 类的继承链</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072001930.png" alt="image-20231107200106838" tabindex="0" loading="lazy"><figcaption>image-20231107200106838</figcaption></figure><p>通过类图，可以看到 <code>DelegatingFilterProxy</code> 继承了 <code>Filter</code> 接口，最终生成了一个过滤器。</p><h3 id="_3-类的属性" tabindex="-1"><a class="header-anchor" href="#_3-类的属性" aria-hidden="true">#</a> 3.类的属性</h3><p>我们通过IDEA打开我们之前的项目，双击<strong>Shift键</strong>，去查找他的源码，我们来简单看一下他的源码。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072003308.png" alt="image-20231107200323099" tabindex="0" loading="lazy"><figcaption>image-20231107200323099</figcaption></figure><p>根据上面代码，看到了熟悉的 <code>targetBeanName</code> 和 <code>targetFilterLifecycle</code> 参数。看到这些参数，不知道大家有没有想到之前我们最开始学习<code>JavaWeb</code>的时候，最初始配置的过滤器，就是在一个web.xml文件中进行双标签配置，为了让大家更清楚的明白，我们下面写一个简单的xml配置。</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>springSecurityFilterChain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>
            org.springframework.web.filter.DelegatingFilterProxy
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>targetBeanName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>springSecurityFilterChain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>targetFilterLifecycle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单讲下这些参数的作用：</p><ul><li><strong>targetBeanName: 字符串</strong></li></ul><p><code>targetBeanName</code> 参数是在 <code>DelegatingFilterProxy</code> 的构造函数中使用的一个字符串参数。它用于指定要代理的目标过滤器的 bean 名称。</p><p>当 <code>DelegatingFilterProxy</code> 接收到请求时，它将查找 Spring 容器中与 <code>targetBeanName</code> 参数匹配的目标过滤器的 bean。然后，<code>DelegatingFilterProxy</code> 将委托实际的过滤工作给找到的目标过滤器实例。</p><p>通过使用 <code>targetBeanName</code> 参数，你可以指定要使用的目标过滤器的 bean 名称，而不需要直接引用目标过滤器的类或实例。</p><p>在<code>示例二</code>中，我们将 <code>DelegatingFilterProxy</code> 配置为过滤器，并通过 <code>&lt;init-param&gt;</code> 元素指定了 <code>targetBeanName</code> 参数的值为 <code>springSecurityFilterChain</code>。这意味着 <code>DelegatingFilterProxy</code> 将在 Spring 容器中查找名为 <code>springSecurityFilterChain</code> 的目标过滤器的 bean，并将实际的过滤工作委托给它。</p><p>请注意，<code>springSecurityFilterChain</code> 应该替换为实际的目标过滤器的 bean 名称。该名称必须与 Spring 容器中定义的目标过滤器的 bean 名称匹配。</p><ul><li><strong>targetFilterLifecycle: 布尔</strong></li></ul><p><code>targetFilterLifecycle</code> 参数是在 <code>DelegatingFilterProxy</code> 的构造函数中使用的一个布尔值参数。它用于指定是否由 <code>DelegatingFilterProxy</code> 负责管理目标过滤器的生命周期。</p><p>如果将 <code>targetFilterLifecycle</code> 参数设置为 <code>true</code>，则 <code>DelegatingFilterProxy</code> 将负责调用目标过滤器的 <code>init()</code> 和 <code>destroy()</code> 方法。这意味着 <code>DelegatingFilterProxy</code> 将在容器启动时自动调用目标过滤器的 <code>init()</code> 方法，并在容器关闭时调用目标过滤器的 <code>destroy()</code> 方法。</p><p>如果将 <code>targetFilterLifecycle</code> 参数设置为 <code>false</code>，则 <code>DelegatingFilterProxy</code> 将不会管理目标过滤器的生命周期。这意味着你需要手动调用目标过滤器的 <code>init()</code> 和 <code>destroy()</code> 方法，确保它们在适当的时候被调用。</p><p>默认情况下，<code>targetFilterLifecycle</code> 参数被设置为 <code>false</code>，即 <code>DelegatingFilterProxy</code> 不会管理目标过滤器的生命周期。如果你希望 <code>DelegatingFilterProxy</code> 管理目标过滤器的生命周期，你可以将 <code>targetFilterLifecycle</code> 参数设置为 <code>true</code>。</p><p>在上面的代码示例中，通过配置将 <code>targetFilterLifecycle</code> 设置为 <code>true</code>，以便让 <code>DelegatingFilterProxy</code> 管理目标过滤器的生命周期。</p><h2 id="_3-delegatingfilterproxy原理" tabindex="-1"><a class="header-anchor" href="#_3-delegatingfilterproxy原理" aria-hidden="true">#</a> 3.DelegatingFilterProxy原理</h2><p><strong>DelegatingFilterProxy</strong> 作为一个过滤器，过滤器的基本声明周期当然不会少。标准过滤器函数三大件：<code>init</code>, <code>doFilter</code>, <code>destroy</code>，这三个函数也是我们最关心的函数，至于 <code>DelegatingFilterProxy</code> 的奥秘也是通过这几个函数体现出来，当然最重要的还是 <code>init</code>, <code>doFilter</code>。下面我们就通过源码的方式一一去查看<strong>DelegatingFilterProxy</strong>他的生命周期。</p><h3 id="_3-1init" tabindex="-1"><a class="header-anchor" href="#_3-1init" aria-hidden="true">#</a> 3.1init</h3><p><code>init</code> 函数定义在 <code>DelegatingFilterProxy</code> 所继承的抽象类 <code>GenericFilterBean</code> 中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">,</span> <span class="token string">&quot;FilterConfig must not be null&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>filterConfig <span class="token operator">=</span> filterConfig<span class="token punctuation">;</span>

        <span class="token comment">// Set bean properties from init parameters.</span>
        <span class="token class-name">PropertyValues</span> pvs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterConfigPropertyValues</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>requiredProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pvs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">BeanWrapper</span> bw <span class="token operator">=</span> <span class="token class-name">PropertyAccessorFactory</span><span class="token punctuation">.</span><span class="token function">forBeanPropertyAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">ResourceLoader</span> resourceLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletContextResourceLoader</span><span class="token punctuation">(</span>filterConfig<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">Environment</span> env <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>env <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                env <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StandardServletEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        bw<span class="token punctuation">.</span><span class="token function">registerCustomEditor</span><span class="token punctuation">(</span><span class="token class-name">Resource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ResourceEditor</span><span class="token punctuation">(</span>resourceLoader<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">initBeanWrapper</span><span class="token punctuation">(</span>bw<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        bw<span class="token punctuation">.</span><span class="token function">setPropertyValues</span><span class="token punctuation">(</span>pvs<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token string">&quot;Failed to set bean properties on filter &#39;&quot;</span> <span class="token operator">+</span>
                                        filterConfig<span class="token punctuation">.</span><span class="token function">getFilterName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;&#39;: &quot;</span> <span class="token operator">+</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Let subclasses do whatever initialization they like.</span>
        <span class="token comment">// 重点关注：🔥🔥🔥🔥🔥🔥</span>
        <span class="token function">initFilterBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;Filter &#39;&quot;</span> <span class="token operator">+</span> filterConfig<span class="token punctuation">.</span><span class="token function">getFilterName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;&#39; configured for use&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072021210.png" alt="image-20231107202119949" tabindex="0" loading="lazy"><figcaption>image-20231107202119949</figcaption></figure><p>接着看下 <code>initFilterBean</code> 的实现，此函数实现定义为 <code>DelegatingFilterProxy</code> 中。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072024737.png" alt="image-20231107202444609" tabindex="0" loading="lazy"><figcaption>image-20231107202444609</figcaption></figure><p>可以看到在<code>DelegatingFilterProxy</code>我们找到了关于initFilterBean的实现，我们来简单解读一下。</p><ol><li><code>synchronized (this.delegateMonitor)</code>：使用<code>synchronized</code>关键字对<code>delegateMonitor</code>进行同步，以确保在多线程环境下只有一个线程可以进入临界区。这样做是为了避免多个线程同时执行初始化操作而导致的竞态条件和数据不一致问题。</li><li><code>if (this.delegate == null)</code>：检查<code>delegate</code>对象是否已经被初始化，如果没有，则继续执行初始化操作。</li><li><code>if (this.targetBeanName == null)</code>：如果没有指定目标bean的名称，就使用过滤器的名称作为目标bean的名称。</li><li><code>this.targetBeanName = getFilterName()</code>：通过<code>getFilterName()</code>方法获取过滤器的名称，并将其作为目标bean的名称。</li><li><code>WebApplicationContext wac = findWebApplicationContext()</code>：调用<code>findWebApplicationContext()</code>方法来查找并获取Spring根应用程序上下文。这个上下文是用来获取bean实例的，因此在初始化<code>delegate</code>之前需要先获取它。</li><li><code>if (wac != null) { this.delegate = initDelegate(wac); }</code>：如果找到了Spring根应用程序上下文，则调用<code>initDelegate</code>方法对<code>delegate</code>进行初始化。这个<code>initDelegate</code>方法可能会根据具体需求做一些初始化工作，比如创建并配置<code>delegate</code>对象。</li></ol><p>总的来说，这段代码的作用是在过滤器初始化时，尽早地初始化<code>delegate</code>对象。通过同步机制和延迟初始化策略，确保在多线程环境下安全地进行初始化操作，并尽可能地提前准备好<code>delegate</code>对象以供后续使用。</p><p>那么如何尽早的初始化delegate对象呢，这个<code>initDelegate</code>方法又做了什么呢，我们接着往下解读。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072029421.png" alt="image-20231107202928322" tabindex="0" loading="lazy"><figcaption>image-20231107202928322</figcaption></figure><ol><li><code>String targetBeanName = getTargetBeanName();</code>：通过<code>getTargetBeanName</code>方法获取目标bean的名称，这个名称在之前的初始化过程中已经确定。</li><li><code>Assert.state(targetBeanName != null, &quot;No target bean name set&quot;);</code>：使用断言确保目标bean的名称不为空，如果为空则抛出异常。这样可以在代码中明确地表达出对目标bean名称的依赖性，以避免潜在的空指针异常。</li><li><code>Filter delegate = wac.getBean(targetBeanName, Filter.class);</code>：通过Spring的应用程序上下文（<code>wac</code>）根据目标bean的名称获取对应的<code>Filter</code>实例。这里利用了Spring的IoC容器来管理和获取<code>Filter</code>实例。</li><li><code>if (isTargetFilterLifecycle()) { delegate.init(getFilterConfig()); }</code>：如果目标<code>Filter</code>需要进行生命周期初始化（例如调用<code>init</code>方法），则调用<code>delegate</code>的<code>init</code>方法并传入过滤器的配置信息。这是为了确保目标<code>Filter</code>在需要时能够正确地进行初始化工作。</li><li><code>return delegate;</code>：返回初始化后的<code>delegate</code>对象，该对象已经准备好被使用了。</li></ol><p>总的来说，这个<code>initDelegate</code>方法的主要作用是根据目标bean的名称从Spring的应用程序上下文中获取对应的<code>Filter</code>实例，并根据需要进行生命周期的初始化工作。这样就能够在<code>initFilterBean</code>方法中及时地准备好<code>delegate</code>对象，以供后续的过滤器处理流程使用。</p><p><strong>这一下就非常清晰了。</strong></p><h3 id="_3-2dofilter" tabindex="-1"><a class="header-anchor" href="#_3-2dofilter" aria-hidden="true">#</a> 3.2dofilter</h3><p><code>doFilter</code> 函数实现定义为 <code>DelegatingFilterProxy</code> 中，我们直接看源码。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072030745.png" alt="image-20231107203046568" tabindex="0" loading="lazy"><figcaption>image-20231107203046568</figcaption></figure><p><strong>我们进行解读：</strong></p><ol><li><code>Filter delegateToUse = this.delegate;</code>：首先将当前已初始化的<code>delegate</code>对象赋给<code>delegateToUse</code>，这里使用了委托模式，即通过<code>delegateToUse</code>来执行具体的过滤器操作。</li><li><code>if (delegateToUse == null) { ... }</code>：检查<code>delegateToUse</code>是否为null，如果为null则表示<code>delegate</code>对象尚未初始化，需要进行延迟初始化。</li><li><code>synchronized (this.delegateMonitor) { ... }</code>：使用<code>synchronized</code>关键字对<code>delegateMonitor</code>进行同步，以确保在多线程环境下只有一个线程可以进入临界区。这样做是为了避免多个线程同时执行初始化操作而导致的竞态条件和数据不一致问题。</li><li><code>delegateToUse = this.delegate;</code>：再次将当前已初始化的<code>delegate</code>对象赋给<code>delegateToUse</code>，因为在同步块外部可能已经有其他线程初始化了<code>delegate</code>对象。</li><li><code>if (delegateToUse == null) { ... }</code>：再次检查<code>delegateToUse</code>是否为null，因为在同步块外部可能已经有其他线程初始化了<code>delegate</code>对象。</li><li><code>WebApplicationContext wac = findWebApplicationContext();</code>：查找并获取Spring根应用程序上下文。如果没有找到上下文，则抛出异常，这是为了确保能够获取到必要的上下文信息用于后续的初始化操作。</li><li><code>delegateToUse = initDelegate(wac);</code>：调用<code>initDelegate</code>方法对<code>delegateToUse</code>进行初始化。这里利用了之前定义的<code>initDelegate</code>方法来完成初始化工作。</li><li><code>this.delegate = delegateToUse;</code>：将初始化后的<code>delegateToUse</code>对象赋给<code>delegate</code>，以便在以后的处理中可以直接使用已经初始化好的<code>delegate</code>对象。</li><li><code>invokeDelegate(delegateToUse, request, response, filterChain);</code>：调用<code>invokeDelegate</code>方法，让已经准备好的<code>delegateToUse</code>对象执行实际的过滤操作。这样就实现了通过代理对象来执行具体过滤器的功能。</li></ol><h3 id="_3-3destroy" tabindex="-1"><a class="header-anchor" href="#_3-3destroy" aria-hidden="true">#</a> 3.3destroy</h3><p><code>destroy</code> 函数实现定义为 <code>DelegatingFilterProxy</code> 中。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072034107.png" alt="image-20231107203459005" tabindex="0" loading="lazy"><figcaption>image-20231107203459005</figcaption></figure><p><strong>这里就没什么好说的了</strong>，<code>DelegatingFilterProxy</code>在这里就像一个甩锅的大爷，根本不需要他去干活，他直接就把其交给委托过滤器来做了。</p><h2 id="_4-delegatingfilterproxy作用" tabindex="-1"><a class="header-anchor" href="#_4-delegatingfilterproxy作用" aria-hidden="true">#</a> 4.DelegatingFilterProxy作用</h2><p>上面我们已经了解了关于DelegatingFilterProxy流程，以及简单看了一下他的源码。这里我们来简单总结一下。</p><p><strong>作用：</strong> 实现把<code>Servlet</code>容器中的<code>Filter</code> 同Spring 容器中的 bean 关联起。是Servlet容器和Spring 的 <code>ApplicationContext</code> 之间的桥梁。</p><ol><li><strong>委托管理</strong>：DelegatingFilterProxy允许将对Servlet规范中的<code>Filter</code>接口的调用委托给Spring应用程序上下文中的一个或多个过滤器Bean。这些过滤器Bean可以由Spring的IoC容器进行管理，并且可以利用Spring的依赖注入等特性来进行配置和定制。</li><li><strong>集成Spring特性</strong>：通过DelegatingFilterProxy，可以将Spring的AOP、事务管理等特性集成到Servlet规范的过滤器中。这样能够更好地利用Spring框架的各种功能来处理Web应用程序中的过滤逻辑。</li><li><strong>延迟初始化</strong>：DelegatingFilterProxy支持延迟初始化和懒加载，它可以在需要时动态地将请求委托给具体的过滤器Bean，而不需要预先在web.xml中配置具体的过滤器类。这样可以避免在应用启动时立即创建所有过滤器实例，从而提高了系统的性能和资源利用率。</li><li><strong>安全性</strong>：DelegatingFilterProxy可以被配置为要求认证的请求使用安全通道，从而提供一定程度的安全保障。</li></ol><p>原生的Filter运行在Servlet容器里边也就是Tomcat服务器当中，而Spring的所书写的过滤器属于Spring工厂。Spring工厂中的过滤器是没有办法拦截Http请求并进行干预的，但是原生Filter就可以做到直接拦截Http请求并进行干预，就比如DelegatingFilterProxy，所以借助它，Spring当中的Filter就可以过滤和干预Http请求了。</p><h2 id="_5-filterchainproxy" tabindex="-1"><a class="header-anchor" href="#_5-filterchainproxy" aria-hidden="true">#</a> 5.FilterChainProxy</h2><h3 id="_5-1filterchainproxy概述" tabindex="-1"><a class="header-anchor" href="#_5-1filterchainproxy概述" aria-hidden="true">#</a> 5.1FilterChainProxy概述</h3><p>在上面的源码环节中，我们已经简单的认识到了<code>FilterChainProxy</code>就是一个过滤器链代理。那具体什么是FilterChainProxy呢？</p><ol><li><strong>统一的安全过滤器链管理</strong>： <ul><li>FilterChainProxy负责统一管理多个SecurityFilterChain，每个SecurityFilterChain都代表一组安全过滤器，用于处理特定模式的请求。这样可以在一个应用中同时支持多个安全策略，或者针对不同的URL模式使用不同的安全过滤器链。</li></ul></li><li><strong>根据请求匹配合适的安全过滤器链</strong>： <ul><li>当收到一个HTTP请求时，FilterChainProxy会根据请求的URL和其他条件来选择合适的SecurityFilterChain，然后按照SecurityFilterChain中定义的顺序执行其中的安全过滤器。这样可以确保请求能够得到正确的安全处理。</li></ul></li><li><strong>灵活的安全策略配置</strong>： <ul><li>FilterChainProxy允许开发人员通过配置来定义多个SecurityFilterChain，以适应不同的安全需求。这种灵活性使得可以针对不同的URL模式或特定的安全需求定制化安全过滤器链。</li></ul></li><li><strong>核心的安全过滤器调度器</strong>： <ul><li>在Spring Security框架中，FilterChainProxy可以看作是核心的安全过滤器调度器，它负责将请求交给正确的安全过滤器链进行处理，从而实现认证、授权、会话管理等安全操作。</li></ul></li></ol><p>下面给出Spring官方给出的解释：</p>`,61),F=e("code",null,"FilterChainProxy",-1),x=e("code",null,"FilterChainProxy",-1),b=e("code",null,"Filter",-1),_={href:"https://springdoc.cn/spring-security/servlet/architecture.html#servlet-securityfilterchain",target:"_blank",rel:"noopener noreferrer"},S=e("code",null,"SecurityFilterChain",-1),P=e("code",null,"Filter",-1),C=e("code",null,"FilterChainProxy",-1),D={href:"https://springdoc.cn/spring-security/servlet/architecture.html#servlet-delegatingfilterproxy",target:"_blank",rel:"noopener noreferrer"},w=e("p",null,"我们通过一张图来更清晰地认识他吧。",-1),z=e("figure",null,[e("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311072047866.png",alt:"image-20231107204747766",tabindex:"0",loading:"lazy"}),e("figcaption",null,"image-20231107204747766")],-1),L=e("h3",{id:"_5-2filterchainproxy的作用",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-2filterchainproxy的作用","aria-hidden":"true"},"#"),n(" 5.2FilterChainProxy的作用")],-1),B=e("code",null,"SecurityFilterChain",-1),N={href:"https://springdoc.cn/spring-security/servlet/architecture.html#servlet-security-filters",target:"_blank",rel:"noopener noreferrer"},T=e("code",null,"FilterChainProxy",-1),q={href:"https://springdoc.cn/spring-security/servlet/architecture.html#servlet-delegatingfilterproxy",target:"_blank",rel:"noopener noreferrer"},U={href:"https://springdoc.cn/spring-security/servlet/architecture.html#servlet-delegatingfilterproxy",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"FilterChainProxy",-1),E=e("code",null,"FilterChainProxy",-1),W=e("code",null,"FilterChainProxy",-1),R=e("code",null,"SecurityContext",-1),H={href:"https://springdoc.cn/spring-security/servlet/exploits/firewall.html#servlet-httpfirewall",target:"_blank",rel:"noopener noreferrer"},M=e("code",null,"HttpFirewall",-1),V=s('<p>此外，它在确定何时应该调用 <code>SecurityFilterChain</code> 方面提供了更大的灵活性。在Servlet容器中，<code>Filter</code> 实例仅基于URL被调用。 然而，<code>FilterChainProxy</code> 可以通过使用 <code>RequestMatcher</code> 接口，根据 <code>HttpServletRequest</code> 中的任何内容确定调用。</p><p>最主要的就是把请求传递给一个或者多个SecurityFilterChain示例进行认证或授权，并且能够需要时进行重定向和返回错误信息。</p><p>我们基于上面的图，来分析一下，一个客户端请求到Servlet中，其中到底是如何经过层层过滤器的。</p><p>首先客户端发起一个Http请求，这个请求会经过原生过滤器<code>Filter-1</code>，此时我们的<code>FilterChain</code>会通过**doFilter()**方法进行放心。之后这个请求会通过<code>Filter-1</code>传递到第二个原生过滤器，也就是我们的<code>DelegatingFilterProxy</code>。此时会搭建一个前往Spring工厂中的桥梁，但是我们并不能直接去通过这个桥梁访问我们的<code>SecurityFilterChain</code>，而是还需要通过桥梁中的另一个过滤器，也就是我们的过滤器链代理<code>FilterChainProxy</code>，他会将我们的请求重定向到SecurityFilterChain中。然后回基于匹配的规则，一个一个去执行Filter。执行完之后，会进行返回，原路返回到我们的FilterChainProxy这个过滤器链代理中。于是由原生过滤器接着向下面过滤器继续请求，如果下面没有过滤器了，则直接到Web资源了。</p><h2 id="_6-securityfilterchain概述" tabindex="-1"><a class="header-anchor" href="#_6-securityfilterchain概述" aria-hidden="true">#</a> 6.SecurityFilterChain概述</h2><p>SecurityFilter 并不是直接放在 Web 项目的原生 <code>FilterChain</code> 中，而是通过一个<code>FlterChainProxy</code>来统管理</p><p><code>FilterChainProxy</code>把 <code>SecurityFilterChain</code> 嵌入到 Web项目的原生过滤器链中DelegatingFilterProxy 把 <code>FilterChainProxy</code> 整合到原生的过滤器链中</p><p><code>FilterChainProxy</code> 是<strong>顶层管理者</strong>，统一管理 SecurityFilter和 <code>SecurityFllterChain</code>过涉器链。</p><p>当请求到达 <code>FilterChainProxy</code> 时，会根据当前请求匹配<code>SecurityFilterChain</code>，然后将请求依次转发给 <code>SecurityFilterChain</code> 中的 SecurityFilter中。</p><h2 id="_6-参考文献" tabindex="-1"><a class="header-anchor" href="#_6-参考文献" aria-hidden="true">#</a> 6.参考文献</h2>',10),j={href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html",target:"_blank",rel:"noopener noreferrer"},I={href:"https://springdoc.cn/spring-security/servlet/architecture.html",target:"_blank",rel:"noopener noreferrer"},O=e("h2",{id:"_7-总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_7-总结","aria-hidden":"true"},"#"),n(" 7.总结")],-1),G=e("p",null,[n("以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是"),e("strong",null,"Leo"),n("，一个在互联网行业的小白，立志成为更好的自己。")],-1),J=e("p",null,[n("如果你想了解更多关于"),e("strong",null,"Leo"),n("，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。")],-1),K=e("figure",null,[e("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311301345907.png",alt:"公众号封面",tabindex:"0",loading:"lazy"}),e("figcaption",null,"公众号封面")],-1);function Q(X,Y){const a=i("ExternalLinkIcon");return c(),l("div",null,[p,e("p",null,[n("Spring 提供了一个名为 "),e("a",d,[u,t(a)]),n(" 的 "),g,n(" 实现，允许在 Servlet 容器的生命周期和 Spring 的 "),k,n(" 之间建立桥梁。Servlet容器允许通过使用自己的标准来注册 "),h,n(" 实例，但它不知道 Spring 定义的 Bean。你可以通过标准的Servlet容器机制来注册 "),m,n("，但将所有工作委托给实现 "),y,n(" 的"),f,n("。")]),v,e("blockquote",null,[e("p",null,[n("Spring Security 的 Servlet 支持包含在 "),F,n(" 中。"),x,n(" 是 SpringSecurity 提供的一个特殊的 "),b,n("，允许通过 "),e("a",_,[S,t(a)]),n(" 委托给许多 "),P,n(" 实例。由于 "),C,n(" 是一个Bean，它通常被包裹在 "),e("a",D,[n("DelegatingFilterProxy"),t(a)]),n(" 中。")])]),w,z,L,e("p",null,[B,n(" 中的 "),e("a",N,[n("Security Filter"),t(a)]),n(" 通常是Bean，但它们是用 "),T,n(" 而不是 "),e("a",q,[n("DelegatingFilterProxy"),t(a)]),n(" 注册的。与直接向Servlet容器或 "),e("a",U,[n("DelegatingFilterProxy"),t(a)]),n(" 注册相比，"),A,n(" 有很多优势。首先，它为 Spring Security 的所有 Servlet 支持提供了一个起点。由于这个原因，如果你试图对 Spring Security 的 Servlet 支持进行故障诊断，在 "),E,n(" 中添加一个调试点是一个很好的开始。")]),e("p",null,[n("其次，由于 "),W,n(" 是 Spring Security 使用的核心，它可以执行一些不被视为可有可无的任务。 例如，它清除了 "),R,n(" 以避免内存泄漏。它还应用Spring Security的 "),e("a",H,[M,t(a)]),n(" 来保护应用程序免受某些类型的攻击。")]),V,e("ul",null,[e("li",null,[e("a",j,[n("https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/DelegatingFilterProxy.html"),t(a)])]),e("li",null,[e("a",I,[n("https://springdoc.cn/spring-security/servlet/architecture.html"),t(a)])])]),O,G,J,K])}const ee=o(r,[["render",Q],["__file","delegate-filter-agents-delegateFilter.html.vue"]]);export{ee as default};
