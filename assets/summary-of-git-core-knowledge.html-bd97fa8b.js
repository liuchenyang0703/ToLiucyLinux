import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o,c,a as t,b as e,d as a,e as n}from"./app-8d307529.js";const r={},g=n('<h1 id="git核心知识总结" tabindex="-1"><a class="header-anchor" href="#git核心知识总结" aria-hidden="true">#</a> Git核心知识总结</h1><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312101543866.png" alt="Git使用" tabindex="0" loading="lazy"><figcaption>Git使用</figcaption></figure><h2 id="_1-什么是git" tabindex="-1"><a class="header-anchor" href="#_1-什么是git" aria-hidden="true">#</a> 1.什么是Git</h2><p>在了解Git之前，我们先了解一下版本控制这个概念。</p><h3 id="_1-1-什么是版本控制" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是版本控制" aria-hidden="true">#</a> 1.1 什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p><h3 id="_1-2-为什么需要版本控制" tabindex="-1"><a class="header-anchor" href="#_1-2-为什么需要版本控制" aria-hidden="true">#</a> 1.2 为什么需要版本控制</h3><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致项目问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p><h3 id="_1-3-本地版本控制系统" tabindex="-1"><a class="header-anchor" href="#_1-3-本地版本控制系统" aria-hidden="true">#</a> 1.3 本地版本控制系统</h3><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。</p><p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p><p>Git是当前最先进、最主流的分布式版本控制系统，免费、开源！核心能力就是版本控制。再具体一点，就是面向代码文件的版本控制，代码的任何修改历史都会被记录管理起来，意味着可以恢复到到以前的任意时刻状态。支持跨区域多人协作编辑，是团队项目开发的必备基础，所以Git也就成了程序员的必备技能。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312101557001.png" alt="image-20231210155711932" tabindex="0" loading="lazy"><figcaption>image-20231210155711932</figcaption></figure><h2 id="_2-git的来源" tabindex="-1"><a class="header-anchor" href="#_2-git的来源" aria-hidden="true">#</a> 2.Git的来源</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312101700497.png" alt="image-20231210170017434" tabindex="0" loading="lazy"><figcaption>image-20231210170017434</figcaption></figure><p>Git是一种分布式版本控制系统，它的设计和开发最初由林纳斯·托瓦兹（Linus Torvalds）领导，他也是Linux操作系统的创始人。Git的开发始于2005年，其背景和初始目的与Linux开发社区的需求密切相关。</p><h3 id="_2-1-背景和初始动机" tabindex="-1"><a class="header-anchor" href="#_2-1-背景和初始动机" aria-hidden="true">#</a> 2.1 背景和初始动机</h3><p>在Git之前，Linux内核的开发使用的是一个名为BitKeeper的商业版本控制系统。这个系统对Linux社区是免费的，但在2005年，由于一些争议和许可问题，Linux社区失去了对BitKeeper的免费许可。这促使托瓦兹寻找一个新的工具来管理Linux内核的开发。</p><p>托瓦兹对版本控制系统有几个明确的需求和目标：</p><ol><li><strong>性能</strong>：由于Linux内核的庞大和复杂性，性能成为一个关键因素。Git需要高效地处理大型项目。</li><li><strong>分布式架构</strong>：Git被设计为分布式系统，意味着每个开发者的计算机上都有整个代码库的完整历史记录，这样可以减少对中央服务器的依赖。</li><li><strong>数据完整性</strong>：Git强调数据的完整性。它通过对文件内容和目录结构使用SHA-1哈希来确保代码历史不被篡改。</li><li><strong>简单的分支和合并</strong>：在Linux开发中，分支和合并操作非常频繁。Git被设计为使这些操作尽可能简单和高效。</li></ol><h3 id="_2-2-git的发展" tabindex="-1"><a class="header-anchor" href="#_2-2-git的发展" aria-hidden="true">#</a> 2.2 Git的发展</h3><p>Git最初是作为一个命令行工具发布的，但随着时间的推移，围绕Git开发了大量的图形界面工具和增强功能，使其更加用户友好。Git迅速在开源社区中获得了广泛的接受，并逐渐成为世界上最流行的版本控制系统。</p><h3 id="_2-3-github和git的普及" tabindex="-1"><a class="header-anchor" href="#_2-3-github和git的普及" aria-hidden="true">#</a> 2.3 GitHub和Git的普及</h3><p>Git的普及也与GitHub这样的平台紧密相关。GitHub是一个基于Web的Git版本库托管服务，它提供了图形界面，并增加了如分叉、拉取请求和社交网络功能等特性，这些都极大地促进了Git的普及和开源文化的发展。</p><h2 id="_3-git的特点" tabindex="-1"><a class="header-anchor" href="#_3-git的特点" aria-hidden="true">#</a> 3.Git的特点</h2><p>开源免费，使用广泛。</p><ul><li>强大的文档（代码）的历史版本管理，直接记录完整快照（完整内容，而非差异），支持回滚、对比。</li><li>分布式多人协作的的代码协同开发，几乎所有操作都是本地执行的，支持代码合并、代码同步。</li><li>简单易用的分支管理，支持高效的创建分支、合并分支。</li></ul><h2 id="_4-git的基本概念" tabindex="-1"><a class="header-anchor" href="#_4-git的基本概念" aria-hidden="true">#</a> 4.Git的基本概念</h2><h3 id="_4-1-概念汇总" tabindex="-1"><a class="header-anchor" href="#_4-1-概念汇总" aria-hidden="true">#</a> 4.1 概念汇总</h3><table><thead><tr><th>概念名称</th><th>描述</th></tr></thead><tbody><tr><td>工作区（Workspace）</td><td>就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区</td></tr><tr><td>暂存区（stage 或 index）</td><td>用于临时存放文件的修改，实际上上它只是一个文件（.git/index），保存待提交的文件列表信息。</td></tr><tr><td>版本库/仓库（Repository）</td><td>Git的管理仓库，管理版本的数据库，记录文件/目录状态的地方，所有内容的修改记录（版本）都在这里。</td></tr><tr><td>服务端/远程仓库（origin 或 remote）</td><td>服务端的版本库，专用的Git服务器，为多人共享提供服务，承担中心服务器的角色。本地版本库通过push指令把代码推送到服务端版本库。</td></tr><tr><td>本地仓库</td><td>用户机器上直接使用的版本库</td></tr><tr><td>分支（Branch）</td><td>分支是从主线分离出去的“副本”，可以独立操作而互不干扰，仓库初始化就有一个默认主分支master。</td></tr><tr><td>头（HEAD）</td><td>HEAD类似一个“指针”，指向当前活动分支的最新版本。</td></tr><tr><td>提交（Commit）</td><td>把暂存区的所有变更的内容提交到当前仓库的活动分支。</td></tr><tr><td>推送（Push）</td><td>将本地仓库的版本推送到服务端（远程）仓库，与他人共享。</td></tr><tr><td>拉取（Pull）</td><td>从服务端（远程）仓库获取更新到本地仓库，获取他人共享的更新。</td></tr><tr><td>获取（Fetch）</td><td>从服务端（远程）仓库更新，作用同拉取（Pull），区别是不会自动合并。</td></tr><tr><td>冲突（Conflict）</td><td>多人对同一文件的工作副本进行更改，并将这些更改合并到仓库时就会面临冲突，需要人工合并处理。</td></tr><tr><td>合并（Merge）</td><td>对有冲突的文件进行合并操作，Git会自动合并变更内容，无法自动处理的冲突内容会提示人工处理。</td></tr><tr><td>标签（Tags）</td><td>标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。</td></tr><tr><td>master（或main）</td><td>仓库的“master”分支，默认的主分支，初始化仓库就有了。Github上创建的仓库默认名字为“main”</td></tr><tr><td>origin/master</td><td>表示远程仓库（origin）的“master”分支</td></tr><tr><td>origin/HEAD</td><td>表示远程仓库（origin）的最新提交的位置，一般情况等于“origin/master”</td></tr></tbody></table><h3 id="_4-2-工作区-暂存区-仓库" tabindex="-1"><a class="header-anchor" href="#_4-2-工作区-暂存区-仓库" aria-hidden="true">#</a> 4.2 工作区/暂存区/仓库</h3><p>工作区（Workspace）就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区。</p><ul><li>在这里新增文件、修改文件内容，或删除文件。</li></ul><p>暂存区（stage或index）用于临时存放文件的修改，实际上上它只是一个文件（.git/index），保存待提交的文件列表信息。</p><ul><li>用git add 命令将工作区的修改保存到暂存区。</li></ul><p>版本库/仓库（Repository仓库）Git的管理仓库，管理版本的数据库，记录文件/目录状态的地方，所有内容的修改记录（版本）都在这里。就是工作区目录下的隐藏文件夹.git，包含暂存区、分支、历史记录等信息。</p><ul><li>用git commit 命令将暂存区的内容正式提交到版本库。</li><li>master 为仓库的默认分支master，HEAD是一个“指针”指向当前分支的最新提交，默认指向最新的master。</li></ul><h3 id="_4-3-git的基本流程" tabindex="-1"><a class="header-anchor" href="#_4-3-git的基本流程" aria-hidden="true">#</a> 4.3 Git的基本流程</h3><p>Git的工作流程核心就下面几个步骤。</p><ol><li>准备仓库：创建或从服务端克隆一个仓库。</li><li>编写代码：在工作目录中添加、修改代码。</li><li>暂存（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>提交（git commit）：将暂存区域的文件提交到Git仓库。</li><li>推送（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>获取更新（fetch/pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ol><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312101708585.png" alt="image-20231210170853553" tabindex="0" loading="lazy"><figcaption>image-20231210170853553</figcaption></figure><ul><li><code>git commit -a</code> 指令省略了add到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是git pull多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code> 、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、 <code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code> 是专门用来撤销修改、回退版本的指令，替代上面checkout的撤销功能。</li></ul><p><strong>基本的 Git 工作流程如下：</strong></p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><h3 id="_4-4-git的状态" tabindex="-1"><a class="header-anchor" href="#_4-4-git的状态" aria-hidden="true">#</a> 4.4 Git的状态</h3><p>Git在执行提交的时候，不是直接将工作区的修改保存到仓库，而是将暂存区域的修改保存到仓库。要提交文件，首先需要把文件加入到暂存区域中。因此，Git管理的文件有三（+2）种状态：</p><ul><li><strong>未跟踪(untracked)：</strong> 新添加的文件，或被移除跟踪的文件，未建立跟踪，通过git add添加暂存并建立跟踪。</li><li><strong>未修改：</strong> 从仓库签出的文件默认状态，修改后就是“已修改”状态了。</li><li><strong>已修改(modified)：</strong> 文件被修改后的状态。</li><li><strong>已暂存(staged)：</strong> 修改、新增的文件添加到暂存区后的状态。</li><li><strong>已提交(committed)：</strong> 从暂存区提交到版本库。</li></ul><h2 id="_5-git的安装" tabindex="-1"><a class="header-anchor" href="#_5-git的安装" aria-hidden="true">#</a> 5.Git的安装</h2>',48),l={href:"https://www.git-scm.com/",target:"_blank",rel:"noopener noreferrer"},p=n(`<ul><li><strong>命令行</strong>：Git的命令通过系统命令行工具，或Git提供的命令行工具运行（<code>C:\\Program Files\\Git\\git-bash.exe</code>）</li><li><strong>GUI工具</strong>：Windows(GUI)、Mac(GUI)工具，需单独安装，使用更简单、更易上手。</li></ul><p><strong>下一步傻瓜式安装即可。</strong></p><p>指令<code>git --version</code>查看安装版本号</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> <span class="token parameter variable">--version</span>
<span class="token function">git</span> version <span class="token number">2.39</span>.2.windows.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-git快速入门" tabindex="-1"><a class="header-anchor" href="#_6-git快速入门" aria-hidden="true">#</a> 6.Git快速入门</h2><h3 id="_6-1-创建仓库" tabindex="-1"><a class="header-anchor" href="#_6-1-创建仓库" aria-hidden="true">#</a> 6.1 创建仓库</h3><p>创建仓库的方式有两种。</p><ol><li>一种是创建全新的仓库，基于<code>git init</code>命令来，会在当前目录初始化创建仓库。</li><li>一种是通过<code>git clone + 仓库地址</code>的方式，一般叫做克隆远程仓库。</li></ol><p>首先准备一个本地的工作目录：GitRepo</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161509452.png" alt="image-20240116150957414" tabindex="0" loading="lazy"><figcaption>image-20240116150957414</figcaption></figure><p>然后gitbash打开，初始化为git仓库。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> init
Initialized empty Git repository <span class="token keyword">in</span> D:/IDEA Workplace/GitRepo/.git/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建完多出了一个被隐藏的<code>.git</code>目录，这就是本地仓库Git的工作目录。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161511605.png" alt="image-20240116151122580" tabindex="0" loading="lazy"><figcaption>image-20240116151122580</figcaption></figure><p>克隆远程仓库，如在gitee上创建的仓库 <code>https://gitee.com/gaoziman/vue3-doc.git</code></p><p>通过以下命令进行克隆：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://gitee.com/gaoziman/vue3-doc.git
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161515865.png" alt="image-20240116151536840" tabindex="0" loading="lazy"><figcaption>image-20240116151536840</figcaption></figure><p>可以看到远程仓库就出现在我们的本地工作空间</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161516696.png" alt="image-20240116151613669" tabindex="0" loading="lazy"><figcaption>image-20240116151613669</figcaption></figure><h3 id="_6-2-暂存区add" tabindex="-1"><a class="header-anchor" href="#_6-2-暂存区add" aria-hidden="true">#</a> 6.2 暂存区add</h3><p><code>git add</code>命令就是把要提交的所有修改放到 <strong>暂存区（Stage）</strong>，然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到仓库。</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git add [file1] [file2]</td><td>添加文件到暂存区，包括修改的文件、新增的文件</td></tr><tr><td>git add [dir]</td><td>同上，添加目录到暂存区，包括子目录</td></tr><tr><td>git add .</td><td>同上，添加<strong>所有</strong>修改、新增文件（未跟踪）到暂存区</td></tr><tr><td>git rm [file]</td><td>删除工作区文件，并且将这次删除放入暂存区</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看仓库状态</span>
$ <span class="token function">git</span> status
On branch master
Your branch is up to <span class="token function">date</span> with <span class="token string">&#39;origin/master&#39;</span><span class="token builtin class-name">.</span>

Changes not staged <span class="token keyword">for</span> commit:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>use <span class="token string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>
        modified:   Nodejs.md

no changes added to commit <span class="token punctuation">(</span>use <span class="token string">&quot;git add&quot;</span> and/or <span class="token string">&quot;git commit -a&quot;</span><span class="token punctuation">)</span>

Administrator@WIN-20231112VVY MINGW64 /d/IDEA Workplace/GitRepo/vue3-doc/01-环境 <span class="token punctuation">(</span>master<span class="token punctuation">)</span>
<span class="token comment"># 添加到指定文件到暂存区</span>
$ <span class="token function">git</span> <span class="token function">add</span> Nodejs.md

Administrator@WIN-20231112VVY MINGW64 /d/IDEA Workplace/GitRepo/vue3-doc/01-环境 <span class="token punctuation">(</span>master<span class="token punctuation">)</span>
<span class="token comment"># 继续查看仓库状态</span>
$ <span class="token function">git</span> status
On branch master
Your branch is up to <span class="token function">date</span> with <span class="token string">&#39;origin/master&#39;</span><span class="token builtin class-name">.</span>

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage<span class="token punctuation">)</span>
        modified:   Nodejs.md

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改之后通过 <code>git add 文件名</code> 即可把文件提交至暂存区</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161602253.png" alt="image-20240116160211205" tabindex="0" loading="lazy"><figcaption>image-20240116160211205</figcaption></figure><h3 id="_6-3-commit提交" tabindex="-1"><a class="header-anchor" href="#_6-3-commit提交" aria-hidden="true">#</a> 6.3 commit提交</h3><p><code>git commit</code>提交是以时间顺序排列被保存到数据库中的，就如游戏关卡一样，每一次提交（commit）就会产生一条记录：<code>id + 描述 + 快照内容</code>。</p><ul><li><strong>commit id</strong>：根据修改的文件内容采用摘要算法（SHA1）计算出不重复的40位字符，这么长是因为Git是分布式的，要保证唯一性、完整性，一般本地指令中可以只用前几位（6）。即使多年以后，依然可通过<code>id</code>找到曾经的任何内容和变动，再也不用担心丢失了。</li><li><strong>描述</strong>：针对本次提交的描述说明，建议<strong>准确</strong>填写，就跟代码中的注释一样，很重要。</li><li><strong>快照</strong>：就是完整的版本文件，以对象树的结构存在仓库下<code>\\.git\\objects</code>目录里，这也是Git效率高的秘诀之一。</li></ul><p>我们可以通过 <code>git reflog</code> 查看所有的提交记录包括回退记录。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161613359.png" alt="image-20240116161319334" tabindex="0" loading="lazy"><figcaption>image-20240116161319334</figcaption></figure><p>我们可以通过提交所有的指令到仓库。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token function">git</span> commit <span class="token parameter variable">-a</span> -m<span class="token string">&#39;修改README的版权信息&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><p>如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span> <span class="token parameter variable">-m</span> <span class="token punctuation">[</span>message<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>取消暂存的文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset filename
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>撤消对文件的修改:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout -- filename
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用参数 <code>--oneline</code> 可以让日志输出更简洁（一行）</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161619232.png" alt="image-20240116161938208" tabindex="0" loading="lazy"><figcaption>image-20240116161938208</figcaption></figure><p><strong>🔥指令：</strong></p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git commit -m &#39;说明&#39;</td><td>提交变更，参数<code>-m</code>设置提交的描述信息，应该正确提交，不带该参数会进入说明编辑模式</td></tr><tr><td>git commit -a</td><td>参数<code>-a</code>，表示直接从工作区提交到版本库，略过了<code>git add</code>步骤，不包括新增的文件</td></tr><tr><td>git commit [file]</td><td>提交暂存区的指定文件到仓库区</td></tr><tr><td>git commit --amend -m</td><td>使用一次新的<code>commit</code>，替代上一次提交，会修改<code>commit</code>的<code>hash</code>值（id）</td></tr><tr><td>git log -n20</td><td>查看日志(最近20条)，不带参数<code>-n</code>则显示所有日志</td></tr><tr><td>git log -n20 --oneline</td><td>参数“<code>--oneline</code>”可以让日志输出更简洁（一行）</td></tr><tr><td>git log -n20 --graph</td><td>参数“<code>--graph</code>”可视化显示分支关系</td></tr><tr><td>git log --follow [file]</td><td>显示某个文件的版本历史</td></tr><tr><td>git blame [file]</td><td>以列表形式显示指定文件的修改记录</td></tr><tr><td>git <strong>reflog</strong></td><td>查看所有可用的历史版本记录（实际是HEAD变更记录），包含被回退的记录（<strong>重要</strong>）</td></tr><tr><td>git status</td><td>查看本地仓库状态，比较常用的指令，加参数<code>-s</code>简洁模式</td></tr></tbody></table><h3 id="_6-4-提交的唯一标识id" tabindex="-1"><a class="header-anchor" href="#_6-4-提交的唯一标识id" aria-hidden="true">#</a> 6.4 提交的唯一标识ID</h3><p>每一个提交都有一个唯一标识，主要就是提交的<code>hash</code>值<code>commit id</code>，在很多指令中会用到，如版本回退、拣选提交等，需要指定一个提交。那标识唯一提交有两种方式：</p><ul><li>首先就是<code>commit id</code>，一个40位编码，指令中使用的时候可以只输入前几位（6位）即可。</li><li>还有一种就是HEAD~n，是基于当前<code>HEAD</code>位置的一个相对坐标。 <ul><li><code>HEAD</code> 表示当前分支的最新版本，是比较常用的参数。</li><li><code>HEAD^</code>上一个版本，<code>HEAD^^</code> 上上一个版本。</li><li><code>HEAD~</code> 或<code>HEAD~1</code> 表示上一个版本，以此类推，<code>HEAD^10</code> 为最近第10个版本。</li><li><code>HEAD@{2}</code>在<code>git reflog</code>日志中标记的提交记录索引。</li></ul></li></ul><p>通过<code>git log</code>、<code>git reflog</code>可以查看历史日志，可以看每次提交的唯一编号（hash）。区别是<code>git reflog</code>可以查看所有操作的记录（实际是HEAD变更记录），包括被撤销回退的提交记录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reflog <span class="token parameter variable">-n10</span>
5acc914 <span class="token punctuation">(</span>HEAD -<span class="token operator">&gt;</span> main<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>: reset: moving to HEAD~
738748b <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>: reset: moving to HEAD~
9312c3e HEAD@<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>: reset: moving to HEAD~
db03fcb HEAD@<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span>: reset: moving to HEAD~
1b81fb3 HEAD@<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>: reset: moving to HEAD~
41ea423 HEAD@<span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span>: reset: moving to HEAD~
d3e15f9 HEAD@<span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span>: reset: moving to d3e15f9
1b81fb3 HEAD@<span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">}</span>: reset: moving to HEAD~1
41ea423 HEAD@<span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span>: reset: moving to HEAD~
d3e15f9 HEAD@<span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">}</span>: reset: moving to HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161622814.png" alt="image-20240116162253750" tabindex="0" loading="lazy"><figcaption>image-20240116162253750</figcaption></figure><h3 id="_6-5-diff比较" tabindex="-1"><a class="header-anchor" href="#_6-5-diff比较" aria-hidden="true">#</a> 6.5 diff比较</h3><p><code>git diff</code>用来比较不同文件版本之间的差异。</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>git diff</strong></td><td>查看暂存区和工作区的差异</td></tr><tr><td>git diff [file]</td><td>同上，指定文件</td></tr><tr><td>git diff --cached</td><td>查看已暂存的改动，就是暂存区与新版本<code>HEAD</code>进行比较</td></tr><tr><td>git diff --staged</td><td>同上</td></tr><tr><td>git diff --cached [file]</td><td>同上，指定文件</td></tr><tr><td>git diff HEAD</td><td>查看已暂存的+未暂存的所有改动，就是与最新版本<code>HEAD</code>进行比较</td></tr><tr><td>git diff HEAD~</td><td>同上，与上一个版本比较。<code>HEAD~</code>表示上一个版本，<code>HEAD~10</code>为最近第10个版本</td></tr><tr><td>git diff [id] [id]</td><td>查看两次提交之间的差异</td></tr><tr><td>git diff [branch]</td><td>查看工作区和分支直接的差异</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看文件的修改</span>
$ <span class="token function">git</span> <span class="token function">diff</span> README.md
 
<span class="token comment"># 查看两次提交的差异</span>
$ <span class="token function">git</span> <span class="token function">diff</span> 8f4244 1da22
 
<span class="token comment"># 显示今天你写了多少行代码：工作区+暂存区</span>
$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token parameter variable">--shortstat</span> <span class="token string">&quot;@{10 day ago}&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-远程仓库" tabindex="-1"><a class="header-anchor" href="#_7-远程仓库" aria-hidden="true">#</a> 7.远程仓库</h2><p>Git作为分布式的版本管理系统，我们每个本地终端都有属于自己的Git仓库。但团队协作还需一个中间仓库，作为控制中心，同步各个仓库。于是服务端（远程）仓库就来承担这个职责，服务端不仅有仓库，还配套相关管理功能，这就是所谓的 <strong>远程仓库</strong> 。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161823621.png" alt="image-20240116182311560" tabindex="0" loading="lazy"><figcaption>image-20240116182311560</figcaption></figure><p>远程仓库有好几种，大致分为下面几种。</p>`,58),h={href:"https://github.com/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://gitee.com/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://coding.net/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/go-gitea/gitea",target:"_blank",rel:"noopener noreferrer"},b=n(`<h3 id="_7-1-远程仓库指令" tabindex="-1"><a class="header-anchor" href="#_7-1-远程仓库指令" aria-hidden="true">#</a> 7.1 远程仓库指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git clone [git地址]</td><td>从远程仓库克隆到本地（当前目录）</td></tr><tr><td>git remote -v</td><td>查看所有远程仓库，不带参数<code>-v</code>只显示名称</td></tr><tr><td>git remote show [remote]</td><td>显示某个远程仓库的信息</td></tr><tr><td>git remote add [name] [url]</td><td>增加一个新的远程仓库，并命名</td></tr><tr><td>git remote rename [old] [new]</td><td>修改远程仓库名称</td></tr><tr><td><strong>git pull [remote] [branch]</strong></td><td>取回远程仓库的变化，并与本地版本合并</td></tr><tr><td><strong>git pull</strong></td><td>同上，针对当前分支</td></tr><tr><td>git fetch [remote]</td><td>获取远程仓库的所有变动到本地仓库，不会自动合并！需要手动合并</td></tr><tr><td><strong>git push</strong></td><td>推送当前分支到远程仓库</td></tr><tr><td>git push [remote] [branch]</td><td>推送本地当前分支到远程仓库的指定分支</td></tr><tr><td>git push [remote] --force/-f</td><td>强行推送当前分支到远程仓库，即使有冲突，⚠️很危险！</td></tr><tr><td>git push [remote] --all</td><td>推送所有分支到远程仓库</td></tr><tr><td>git push –u</td><td>参数<code>–u</code>表示与远程分支建立关联，第一次执行的时候用，后面就不需要了</td></tr><tr><td>git remote rm [remote-name]</td><td>删除远程仓库</td></tr><tr><td>git pull --rebase</td><td>使用rebase的模式进行合并</td></tr></tbody></table><h3 id="_7-2-push和pull" tabindex="-1"><a class="header-anchor" href="#_7-2-push和pull" aria-hidden="true">#</a> 7.2 push和pull</h3><p><code>git push</code>、<code>git pull</code>是团队协作中最常用的指令，用于同步本地、服务端的更新，与他人协作。</p><p><strong>🔸推送</strong>（push）：推送本地仓库到远程仓库。</p><ul><li>如果推送的更新与服务端存在冲突，则会被拒绝，<code>push</code>失败。一般是有其他人推送了代码，导致文件冲突，可以先<code>pull</code>代码，在本地进行合并，然后再<code>push</code>。</li></ul><p><strong>🔸拉取</strong>（pull）：从服务端（远程）仓库更新到本地仓库。</p><ul><li><code>git pull</code>：拉取服务端的最新提交到本地，并与本地合并，合并过程同分支的合并。</li><li><code>git fetch</code>：拉取服务端的最新提交到本地，不会自动合并，也不会更新工作区。</li></ul><h3 id="_7-4-fetch和pull有什么区别" tabindex="-1"><a class="header-anchor" href="#_7-4-fetch和pull有什么区别" aria-hidden="true">#</a> 7.4 fetch和pull有什么区别</h3><h4 id="_1-git-fetch" tabindex="-1"><a class="header-anchor" href="#_1-git-fetch" aria-hidden="true">#</a> 1. Git Fetch</h4><p><code>git fetch</code>命令用于从另一个仓库（例如，远程仓库）下载新的分支和数据，但不会自动合并或修改你当前工作目录下的文件或分支。<code>fetch</code> 命令会把远程仓库的所有信息拉取到本地仓库，但这些改动不会反映在你的当前工作分支上，除非你明确地进行合并。</p><p>换句话说，<code>git fetch</code>是一种安全的方式来查看别人已经做了哪些工作，而这些变更在你用<code>git fetch</code>之后不会影响你当前的工作状态。如果你想要让这些变更影响你的当前分支，你需要用<code>git merge</code>手动合并，如<code>git merge origin/master</code>（如果你是从<code>master</code>分支上fetch的）。</p><h4 id="_2-git-pull" tabindex="-1"><a class="header-anchor" href="#_2-git-pull" aria-hidden="true">#</a> 2. Git Pull</h4><p><code>git pull</code>命令实际上是<code>git fetch</code>加上<code>git merge</code>命令的组合。当你执行<code>git pull</code>，Git会从远程仓库获取最新的版本信息，然后尝试自动合并到你当前的分支。通常情况下，这意味着它将远程的更新内容合并到你当前分支的本地副本中。</p><p>在简单的情况下，<code>git pull</code>会顺利地将远程变更合并到你的本地分支，你的工作流程可以无缝继续。然而，如果在fetch的数据与你本地的修改存在冲突时，你可能需要手动解决这些冲突。</p><h4 id="_3-使用场景对比" tabindex="-1"><a class="header-anchor" href="#_3-使用场景对比" aria-hidden="true">#</a> 3. 使用场景对比</h4><p>在不清楚远程分支的情况下，你可能更倾向于首先使用<code>git fetch</code>来查看有哪些更新，待检查完更新内容后再决定是否合并到当前分支。这是一种更为谨慎的做法，尤其适用于复杂的合并操作，或者当你不希望自动将更改应用到本地仓库时使用。</p><p>另一方面，如果你相信远程的变更不会引起任何问题，并且希望你的本地分支保持与远程分支的同步，可以直接使用<code>git pull</code>。</p><h4 id="_4-案例" tabindex="-1"><a class="header-anchor" href="#_4-案例" aria-hidden="true">#</a> 4.案例</h4><p>获取远程仓库的更新数据，但不合并到当前分支：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> fetch origin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>获取远程仓库的更新数据并自动合并到当前分支：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> pull origin master  <span class="token comment"># 拉取origin远程仓库的master分支并合并到当前分支</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>git fetch</code>用于安全地查看远程变更，而<code>git pull</code>则用于获取并立刻应用这些变更。两者合适的使用取决于你想如何管理远程数据和本地分支的关系。</p><h2 id="_8-分支" tabindex="-1"><a class="header-anchor" href="#_8-分支" aria-hidden="true">#</a> 8.分支</h2><p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。</p><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401161937762.png" alt="image-20240116193758724" tabindex="0" loading="lazy"><figcaption>image-20240116193758724</figcaption></figure><p>Git 分支实际上是指向更改快照的指针。</p><p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p><h3 id="_8-1-branch" tabindex="-1"><a class="header-anchor" href="#_8-1-branch" aria-hidden="true">#</a> 8.1 branch</h3><p>加入，准备1月份发布新版本，要新开发一些新功能，占领市场。你和小伙伴 <strong>张三</strong> 一起负责开发一个新功能A，开发周期2周，在这两周你们的代码不能影响其他人，不影响主分支。这个时候就可以为这个新功能创建一个分支，你们两在这个分支上干活，2周后代码开发完了、测试通过，就可以合并进要发版的开发分支了。安全、高效，不影响其他人工作，完美！</p><p>实际开发中，我们可能会有多个分支进行开发。</p><ul><li><strong>master</strong>：作为主分支，存放稳定的代码，就是开发后测试通过的代码，不允许随便修改和合并。</li><li><strong>开发分支</strong>：用于团队日常开发用，比如团队计划12月份开发10个功能并发版，则在此分支上进行，不影响主分支的稳定，如果我们开发到一个成熟阶段，依然可以合并到master主分支。</li></ul><blockquote><p><strong>分支</strong>就是指向某一个提交记录的“指针”引用，因此创建分支是非常快的，不管仓库多大。当我们运行<code>git branch dev</code>创建了一个名字为<code>dev</code>的分支，Git实际上是在<code>.git\\refs\\heads</code>下创建一个<code>dev</code>的引用文件（没有扩展名）。</p></blockquote><h3 id="_8-2-分支命令" tabindex="-1"><a class="header-anchor" href="#_8-2-分支命令" aria-hidden="true">#</a> 8.2 分支命令</h3><p>我这里讲这些命令总结为思维导图，大家可以参考一下。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162021467.png" alt="注册登录" tabindex="0" loading="lazy"><figcaption>注册登录</figcaption></figure><p>列出了当前的所有分支，星号“*”开头的“main”为当前活动分支。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162023265.png" alt="image-20240116202321231" tabindex="0" loading="lazy"><figcaption>image-20240116202321231</figcaption></figure><h3 id="_8-3-分支冲突" tabindex="-1"><a class="header-anchor" href="#_8-3-分支冲突" aria-hidden="true">#</a> 8.3 分支冲突</h3><p>把两个分支的修改内容合并到一起，常用的合并指令<code>git merge [branch]</code>，将分支<code>[branch]</code>合并到当前分支。根据要合并的内容的不同，具体合并过程就会有多种情况。</p><p>首先我们准备一个案例项目，我已经在gitee准备好了，非常简单，只有三个简单的文件。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162043502.png" alt="image-20240116204339462" tabindex="0" loading="lazy"><figcaption>image-20240116204339462</figcaption></figure><h4 id="_1-快速合并" tabindex="-1"><a class="header-anchor" href="#_1-快速合并" aria-hidden="true">#</a> 1. 快速合并</h4><p>合并<code>dev</code>到<code>master</code>，注意要先切换到<code>master</code>分支，然后执行<code>git merge dev</code>，把<code>dev</code>合并到当前分支。</p><p>首先创建dev分支并切换到dev分支上去。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162044205.png" alt="image-20240116204443180" tabindex="0" loading="lazy"><figcaption>image-20240116204443180</figcaption></figure><p>然后再dev分支上面创建一个b.txt文件，随之提交到远程仓库中。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162046492.png" alt="image-20240116204657448" tabindex="0" loading="lazy"><figcaption>image-20240116204657448</figcaption></figure><p>可以看到我们远程仓库的dev分支上面已经有了b.txt这个文件。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162047799.png" alt="image-20240116204734747" tabindex="0" loading="lazy"><figcaption>image-20240116204734747</figcaption></figure><p>然后切换到master分支上面，把dev分支合并到我们的master主分支上面。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162048409.png" alt="image-20240116204857373" tabindex="0" loading="lazy"><figcaption>image-20240116204857373</figcaption></figure><p>同时可以看到我们远程仓库中master分支也同步到了dev分支的b.txt文件。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162050129.png" alt="image-20240116205007064" tabindex="0" loading="lazy"><figcaption>image-20240116205007064</figcaption></figure><h4 id="_2-普通合并" tabindex="-1"><a class="header-anchor" href="#_2-普通合并" aria-hidden="true">#</a> 2. 普通合并</h4><p>如果<code>master</code>有变更，存在分支交叉，则会把两边的变更合并成一个提交。</p><ul><li>如果两边变更的文件不同，没有什么冲突，就自动合并了。</li><li>如果有修改同一个文件，则会存在冲突，到底该采用哪边的，程序无法判断，就换产生冲突。冲突内容需要人工修改后再重新提交，才能完成最终的合并。</li></ul><p>我们在远程仓库master分支中手动更改a.txt文件来演示。</p><h5 id="_1-第一种情况" tabindex="-1"><a class="header-anchor" href="#_1-第一种情况" aria-hidden="true">#</a> 1. 第一种情况</h5><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162131690.png" alt="image-20240116213126651" tabindex="0" loading="lazy"><figcaption>image-20240116213126651</figcaption></figure><p>此时我们在本地仓库中更改其他文件，只要不是a.txt即可，然后push到远程。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162134374.png" alt="image-20240116213411294" tabindex="0" loading="lazy"><figcaption>image-20240116213411294</figcaption></figure><p>此时发现我们当前本地仓库的版本号与远程仓库master分支的版本号不一致，导致提交不上去。</p><p>这种情况还是比较简单的，只需要通过 <code>git pull</code> 命令将本地版本与远程版本同步即可。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162135327.png" alt="image-20240116213549288" tabindex="0" loading="lazy"><figcaption>image-20240116213549288</figcaption></figure><p>此时会进行自动合并到本地分支，并当做一次提交，提交信息大家也可以进行更改，我这里默认即可。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162137659.png" alt="image-20240116213707628" tabindex="0" loading="lazy"><figcaption>image-20240116213707628</figcaption></figure><p>此时再次提交即可成功提交到远程仓库中。</p><h5 id="_2-第二种情况" tabindex="-1"><a class="header-anchor" href="#_2-第二种情况" aria-hidden="true">#</a> 2. 第二种情况</h5><p>上面那种方式处理起来比较简单，因为是处理不同的文件。</p><p>下面我来演示一下对于同一个文件冲突情况进行解决。</p><p>我们在远程仓库手动添加了以下这句话进行对b.txt文件的修改。(可以理解为程序员A修改了b.txt文件并提交到远程仓库中去、。)</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162141415.png" alt="image-20240116214108341" tabindex="0" loading="lazy"><figcaption>image-20240116214108341</figcaption></figure><p>此时程序员B也在本地修改了b.txt文件。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162142539.png" alt="image-20240116214238509" tabindex="0" loading="lazy"><figcaption>image-20240116214238509</figcaption></figure><p>然后通过一系列命令提交至远程仓库。</p><p>可以发现出现冲突之后，我们立即通过git pull 命令进行了同步，但是初始我们的这里发生了很多变化，变成了<strong>master | MENERGING</strong>。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162148588.png" alt="image-20240116214800549" tabindex="0" loading="lazy"><figcaption>image-20240116214800549</figcaption></figure><p>此时这种情况就是因为在自动合并的时候出现了冲突，git无法帮助我们解决，需要我们自己手动解决冲突。</p><p>然后我们在本地打开b.txt文件。</p><p>可以看到确实也把远程更改的内容同步过来了，这里就需要我们手动解决，由我们和另外一个程序员协商到底是保留谁的内容或者是都保留。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162150303.png" alt="image-20240116215057222" tabindex="0" loading="lazy"><figcaption>image-20240116215057222</figcaption></figure><p>此时我们觉得都进行保留，然后删除其他多余内容。</p><p>然后进行代码提交。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162154566.png" alt="image-20240116215416532" tabindex="0" loading="lazy"><figcaption>image-20240116215416532</figcaption></figure><p>此时可以发现远程仓库b.txt文件内容已经发现了改变，并且是由我们手动解决并提交的。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162155902.png" alt="image-20240116215517850" tabindex="0" loading="lazy"><figcaption>image-20240116215517850</figcaption></figure><p>大功告成!!</p><h2 id="_9-git的版本回退" tabindex="-1"><a class="header-anchor" href="#_9-git的版本回退" aria-hidden="true">#</a> 9.Git的版本回退</h2><p>如果发现我们编写代码中写错了要怎么办，但又分好几种情况，我们依次往下看。</p><ul><li>❓还没提交的怎么撤销？ -- checkout <ul><li>还未提交的修改（工作区、暂存区）不想要了，用签出指令（checkout）进行撤销清除。</li><li>或者用<code>checkout</code>的新版回滚指令<code>reset</code>。</li></ul></li><li>❓<strong>已提交但么有push的提交如何撤销？</strong>—— <code>reset</code>、<code>revert</code></li><li>❓<strong>已push的提交如何撤销？</strong>—— 同上，先本地撤销，然后强制推送<code>git push origin -f</code>，<strong>⚠️注意慎用！</strong> 记得先<code>pull</code>获取更新。</li></ul><h3 id="_9-1-版本回退命令" tabindex="-1"><a class="header-anchor" href="#_9-1-版本回退命令" aria-hidden="true">#</a> 9.1 版本回退命令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git checkout .</td><td>撤销工作区的（未暂存）修改，把暂存区恢复到工作区。不影响暂存区，如果没暂存，则撤销所有工作区修改</td></tr><tr><td>git checkout [file]</td><td>同上，<code>file</code>指定文件</td></tr><tr><td>git checkout HEAD .</td><td>撤销工作区、暂存区的修改，用<code>HEAD</code>指向的当前分支最新版本替换工作区、暂存区</td></tr><tr><td>git checkout HEAD [file]</td><td>同上，<code>file</code>指定文件</td></tr><tr><td></td><td></td></tr><tr><td>git reset</td><td>撤销暂存区状态，同<code>git reset HEAD</code>，不影响工作区</td></tr><tr><td>git reset HEAD [file]</td><td>同上，指定文件<code>file</code>，<code>HEAD</code>可省略</td></tr><tr><td>git reset [commit]</td><td>回退到指定版本，清空暂存区，不影响工作区。工作区需要手动<code>git checkout</code>签出</td></tr><tr><td>git reset --soft [commit]</td><td>移动分支<code>master</code>、<code>HEAD</code>到指定的版本，不影响暂存区、工作区，需手动<code>git checkout</code>签出更新</td></tr><tr><td>git reset --hard HEAD</td><td>撤销工作区、暂存区的修改，用当前最新版</td></tr><tr><td>git reset --hard HEAD~</td><td>回退到上一个版本，并重置工作区、暂存区内容。</td></tr><tr><td>git reset --hard [commit]</td><td>回退到指定版本，并重置工作区、暂存区内容。</td></tr><tr><td></td><td></td></tr><tr><td>git <strong>revert</strong>[commit]</td><td>撤销一个提交，会用一个新的提交（原提交的逆向操作）来完成撤销操作，如果已<code>push</code>则重新<code>push</code>即可</td></tr></tbody></table><ul><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、<code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li></ul><h4 id="_1-只撤销工作区的修改-未暂存" tabindex="-1"><a class="header-anchor" href="#_1-只撤销工作区的修改-未暂存" aria-hidden="true">#</a> 1. 只撤销工作区的修改（未暂存）</h4><p>撤销工作区的（未暂存）修改，把暂存区恢复到工作区。不影响暂存区，如果没暂存，则撤销所有工作区修改。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162209685.png" alt="image-20240116220920634" tabindex="0" loading="lazy"><figcaption>image-20240116220920634</figcaption></figure><h4 id="_2-撤销工作区、暂存区的修改" tabindex="-1"><a class="header-anchor" href="#_2-撤销工作区、暂存区的修改" aria-hidden="true">#</a> 2. 撤销工作区、暂存区的修改</h4><p>撤销工作区、暂存区的修改，用<code>HEAD</code>指向的当前分支最新版本替换工作区、暂存区</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162210477.png" alt="image-20240116221002447" tabindex="0" loading="lazy"><figcaption>image-20240116221002447</figcaption></figure><h3 id="_9-2-reset" tabindex="-1"><a class="header-anchor" href="#_9-2-reset" aria-hidden="true">#</a> 9.2 reset</h3><p><code>reset</code>是专门用来撤销修改、回退版本的指令，支持的场景比较多，多种撤销姿势，所以参数组合也比较多。简单理解就是移动<code>master</code>分支、<code>HEAD</code>的“指针”地址，理解这一点就基本掌握<code>reset</code>了。</p><p><code>reset</code>有三种模式，对应三种参数：<code>mixed</code>（默认模式）、<code>soft</code>、<code>hard</code>。三种参数的主要区别就是对工作区、暂存区的操作不同。</p><ul><li><code>mixed</code>为默认模式，参数可以省略。</li><li>只有<code>hard</code>模式会重置工作区、暂存区，一般用这个模式会多一点。</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162211077.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><table><thead><tr><th>模式名称</th><th><strong>描述</strong></th><th><strong>HEAD的位置</strong></th><th><strong>暂存区</strong></th><th><strong>工作区</strong></th></tr></thead><tbody><tr><td><strong>soft</strong></td><td>回退到某一个版本，工作区不变，需手动<code>git checkout</code></td><td>修改</td><td>不修改</td><td>不修改</td></tr><tr><td><strong>mixed</strong>(默认)</td><td>撤销暂存区状态，不影响工作区，需手动<code>git checkout</code></td><td>修改</td><td>修改</td><td>不修改</td></tr><tr><td><strong>hard</strong></td><td>重置未提交修改（工作区、暂存区）</td><td>修改</td><td>修改</td><td>修改</td></tr></tbody></table><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h4 id="_1-撤销暂存区" tabindex="-1"><a class="header-anchor" href="#_1-撤销暂存区" aria-hidden="true">#</a> 1. 撤销暂存区</h4><p>这个其实跟刚刚的 <code>git checkout HEAD . </code>是一样的。</p><h4 id="_2-撤销工作区、暂存区修改" tabindex="-1"><a class="header-anchor" href="#_2-撤销工作区、暂存区修改" aria-hidden="true">#</a> 2. 撤销工作区、暂存区修改</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_3-回退版本库到上一个版本-并重置工作区、暂存" tabindex="-1"><a class="header-anchor" href="#_3-回退版本库到上一个版本-并重置工作区、暂存" aria-hidden="true">#</a> 3. 回退版本库到上一个版本，并重置工作区、暂存</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到他已经回到了我们上一个版本。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162215007.png" alt="image-20240116221511082" tabindex="0" loading="lazy"><figcaption>image-20240116221511082</figcaption></figure><p>通过git log 日志查看也没有了之前的记录，而是被HEAD指向到上一个版本。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162216047.png" alt="image-20240116221622011" tabindex="0" loading="lazy"><figcaption>image-20240116221622011</figcaption></figure><h4 id="_4-回到原来的版本-并重置工作区、暂存" tabindex="-1"><a class="header-anchor" href="#_4-回到原来的版本-并重置工作区、暂存" aria-hidden="true">#</a> 4. 回到原来的版本，并重置工作区、暂存</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 891350d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到他又回到上上一步，也就是对上一步操作进行撤销。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162219695.png" alt="image-20240116221923664" tabindex="0" loading="lazy"><figcaption>image-20240116221923664</figcaption></figure><h4 id="_5-查看所有历史提交记录" tabindex="-1"><a class="header-anchor" href="#_5-查看所有历史提交记录" aria-hidden="true">#</a> 5. 查看所有历史提交记录</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reflog
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162220118.png" alt="image-20240116222012073" tabindex="0" loading="lazy"><figcaption>image-20240116222012073</figcaption></figure><h2 id="_10-idea集成git" tabindex="-1"><a class="header-anchor" href="#_10-idea集成git" aria-hidden="true">#</a> 10.IDEA集成Git</h2><p>通过以上内容，我们对Git整个工作流程有了一些认识，以及知道如何使用Git进行平时的开发。</p><p>但是在真实的开发中，我们可能并不是使用命令行进行操作，而是在IDEA中进行图形化操作，我们写完代码即可进行提交。</p><p>我们打开IDEA，依次在settings ---》Version Control ---》 Git。</p><p>选择自己的Git安装路径，然后进行测试看是否成功。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162159430.png" alt="image-20240116215908346" tabindex="0" loading="lazy"><figcaption>image-20240116215908346</figcaption></figure><p>点击Test之后看到自己对应的Git版本号之后即可说明我们初步测试成功。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162159546.png" alt="image-20240116215946507" tabindex="0" loading="lazy"><figcaption>image-20240116215946507</figcaption></figure><p>然后就可以在IDEA中进行代码的编写。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162203110.png" alt="image-20240116220306984" tabindex="0" loading="lazy"><figcaption>image-20240116220306984</figcaption></figure><p>然后讲代码push到远程仓库。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401162203721.png" alt="image-20240116220340690" tabindex="0" loading="lazy"><figcaption>image-20240116220340690</figcaption></figure><p>相比于命令行，IDEA的图形化操作是不是让人更省心，简单易上手。</p><h2 id="_11-参考文献" tabindex="-1"><a class="header-anchor" href="#_11-参考文献" aria-hidden="true">#</a> 11.参考文献</h2>`,140),v={href:"https://git-scm.com/book/zh/v2",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.yuque.com/kanding/ktech/ccgylqhnb94ug4bu#LlJg3",target:"_blank",rel:"noopener noreferrer"},_={href:"https://javaguide.cn/tools/git/git-intro.html",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.yiibai.com/git",target:"_blank",rel:"noopener noreferrer"},z=t("h2",{id:"_12-总结",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_12-总结","aria-hidden":"true"},"#"),e(" 12.总结")],-1),y=t("p",null,[e("以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是"),t("strong",null,"Leo"),e("，一个在互联网行业的小白，立志成为更好的自己。")],-1),G=t("p",null,[e("如果你想了解更多关于"),t("strong",null,"Leo"),e("，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。")],-1),E=t("figure",null,[t("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312101810620.png",alt:"公众号封面",tabindex:"0",loading:"lazy"}),t("figcaption",null,"公众号封面")],-1);function A(D,H){const i=s("ExternalLinkIcon");return o(),c("div",null,[g,t("p",null,[e("Git官网："),t("a",l,[e("https://www.git-scm.com/"),a(i)]),e(" 下载安装包进行安装。Git的使用有两种方式：")]),p,t("ul",null,[t("li",null,[e("公共Git服务器，如"),t("a",h,[e("Github"),a(i)]),e("、"),t("a",u,[e("码云Gitee"),a(i)]),e("、"),t("a",m,[e("腾讯Coding"),a(i)]),e("等。")]),t("li",null,[e("搭建私有Git服务器，如开源的Gitlab、"),t("a",f,[e("Gitea"),a(i)]),e("、等。")])]),b,t("ul",null,[t("li",null,[t("a",v,[e("https://git-scm.com/book/zh/v2"),a(i)])]),t("li",null,[t("a",k,[e("https://www.yuque.com/kanding/ktech/ccgylqhnb94ug4bu#LlJg3"),a(i)])]),t("li",null,[t("a",_,[e("https://javaguide.cn/tools/git/git-intro.html"),a(i)])]),t("li",null,[t("a",x,[e("https://www.yiibai.com/git"),a(i)])])]),z,y,G,E])}const w=d(r,[["render",A],["__file","summary-of-git-core-knowledge.html.vue"]]);export{w as default};
