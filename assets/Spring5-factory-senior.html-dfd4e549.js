const e=JSON.parse('{"key":"v-901b7e2e","path":"/framework/spring/Spring5-factory-senior.html","title":"Spring工厂高级特性","lang":"zh-CN","frontmatter":{"title":"Spring工厂高级特性","icon":"circle-info","order":3,"category":["spring"],"tag":["spring"],"pageview":false,"date":"2023-08-29T00:00:00.000Z","comment":false,"breadcrumb":false,"description":"1. 对象的生命周期 1.1 什么是对象的生命周期 含义：一个对象创建、存活、消亡的一个完整过程。 1.2 为什么要学习对象的生命周期 由 Spring 负责对象的创建、存活、销毁，了解生命周期，有利于我们使用好Spring为我们创建的对象。 1.3 声明周期的三个阶段 1. 创建阶段\\rscope=\\"singleton\\"; 此时会在创建Spring工厂...","head":[["meta",{"property":"og:url","content":"http://liuchenyang.top/ToLiucyLinux/framework/spring/Spring5-factory-senior.html"}],["meta",{"property":"og:site_name","content":"ToLiucyLinux"}],["meta",{"property":"og:title","content":"Spring工厂高级特性"}],["meta",{"property":"og:description","content":"1. 对象的生命周期 1.1 什么是对象的生命周期 含义：一个对象创建、存活、消亡的一个完整过程。 1.2 为什么要学习对象的生命周期 由 Spring 负责对象的创建、存活、销毁，了解生命周期，有利于我们使用好Spring为我们创建的对象。 1.3 声明周期的三个阶段 1. 创建阶段\\rscope=\\"singleton\\"; 此时会在创建Spring工厂..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Liucy"}],["meta",{"property":"article:tag","content":"spring"}],["meta",{"property":"article:published_time","content":"2023-08-29T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring工厂高级特性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-08-29T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Liucy\\",\\"url\\":\\"http://liuchenyang.top\\"}]}"]]},"headers":[{"level":2,"title":"1. 对象的生命周期","slug":"_1-对象的生命周期","link":"#_1-对象的生命周期","children":[{"level":3,"title":"1.1  什么是对象的生命周期","slug":"_1-1-什么是对象的生命周期","link":"#_1-1-什么是对象的生命周期","children":[]},{"level":3,"title":"1.2 为什么要学习对象的生命周期","slug":"_1-2-为什么要学习对象的生命周期","link":"#_1-2-为什么要学习对象的生命周期","children":[]},{"level":3,"title":"1.3 声明周期的三个阶段","slug":"_1-3-声明周期的三个阶段","link":"#_1-3-声明周期的三个阶段","children":[]}]},{"level":2,"title":"2. 配置文件参数化","slug":"_2-配置文件参数化","link":"#_2-配置文件参数化","children":[{"level":3,"title":"2.1 什么是配置文件参数化","slug":"_2-1-什么是配置文件参数化","link":"#_2-1-什么是配置文件参数化","children":[]},{"level":3,"title":"2.2 配置文件参数化的开发步骤:","slug":"_2-2-配置文件参数化的开发步骤","link":"#_2-2-配置文件参数化的开发步骤","children":[]}]},{"level":2,"title":"3. 自定义类型转换器","slug":"_3-自定义类型转换器","link":"#_3-自定义类型转换器","children":[{"level":3,"title":"1. 什么是类型转换器","slug":"_1-什么是类型转换器","link":"#_1-什么是类型转换器","children":[]},{"level":3,"title":"2. 类型转换器的作用","slug":"_2-类型转换器的作用","link":"#_2-类型转换器的作用","children":[]},{"level":3,"title":"3. 为什么要自定义类型转换器？","slug":"_3-为什么要自定义类型转换器","link":"#_3-为什么要自定义类型转换器","children":[]},{"level":3,"title":"4.  自定义类型转换器的开发步骤","slug":"_4-自定义类型转换器的开发步骤","link":"#_4-自定义类型转换器的开发步骤","children":[]},{"level":3,"title":"5. 细节","slug":"_5-细节","link":"#_5-细节","children":[]}]},{"level":2,"title":"6. 后置处理Bean","slug":"_6-后置处理bean","link":"#_6-后置处理bean","children":[{"level":3,"title":"6.1 BeanPostProcessor的作用：","slug":"_6-1-beanpostprocessor的作用","link":"#_6-1-beanpostprocessor的作用","children":[]},{"level":3,"title":"6.2 后置处理Bean的运行原理分析","slug":"_6-2-后置处理bean的运行原理分析","link":"#_6-2-后置处理bean的运行原理分析","children":[]},{"level":3,"title":"6.3 BeanPostProcessor的开发步骤","slug":"_6-3-beanpostprocessor的开发步骤","link":"#_6-3-beanpostprocessor的开发步骤","children":[]}]}],"git":{},"readingTime":{"minutes":10.38,"words":3114},"filePathRelative":"framework/spring/Spring5-factory-senior.md","localizedDate":"2023年8月29日","copyright":{"author":"LiucyLinux(LiucyLinux.cn)","license":"MIT"},"autoDesc":true}');export{e as data};
