import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as i,c as o,a as e,b as t,d as r,e as c}from"./app-8d307529.js";const l={},d=c(`<h1 id="springsecurity6-回顾filter" tabindex="-1"><a class="header-anchor" href="#springsecurity6-回顾filter" aria-hidden="true">#</a> SpringSecurity6 | 回顾Filter</h1><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202310302354916.png" alt="image-20231030235443828" tabindex="0" loading="lazy"><figcaption>image-20231030235443828</figcaption></figure><h2 id="_1-前言" tabindex="-1"><a class="header-anchor" href="#_1-前言" aria-hidden="true">#</a> 1.前言</h2><p>大家好，我是Leo哥🫣🫣🫣，上一节我们通过一个HelloWorld案例，以代码的方式实现了我们项目添加登录鉴权功能，只是通过一个就轻松实现了这个功能。那么他其中的原理是什么呢，带着疑问，我们后面几节课主要学习一下如何实现这些的原理。好了，话不多说让我们开始吧😎😎😎。</p><h2 id="_2-遗留问题" tabindex="-1"><a class="header-anchor" href="#_2-遗留问题" aria-hidden="true">#</a> 2.遗留问题</h2><ol><li>在引入SpringSecurity依赖后，为什么所有请求就需要先做登录认证了呢?</li><li>登录页面是怎么产生的?</li><li>登录页面可以自定义吗?</li></ol><p><strong>后面几篇文章，我们会带着这些问题去研究SpringSecurity，并找出问题的答案。</strong></p><h2 id="_3-请求流程" tabindex="-1"><a class="header-anchor" href="#_3-请求流程" aria-hidden="true">#</a> 3.请求流程</h2><p>一个请求发出之后的基本流程是怎么样的呢，我们的请求是如何被拦截的呢，下面我们简单的来看一下流程图。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311052218806.png" alt="image-20231105221856734" tabindex="0" loading="lazy"><figcaption>image-20231105221856734</figcaption></figure><p><strong>流程详解：</strong></p><ol><li>客户端通过浏览器或其他方式向服务器发送请求，<strong>SpringSecurity</strong>会拦截该请求，并将其交给安全过滤器链进行处理。</li><li>安全过滤器链是<strong>SpringSecurity</strong>的核心组件，由多个**过滤器(Filter)**组成。每个过滤器都有特定的功能，例如身份验证、授权、会话管理等。在处理请求时，安全过滤器链会按照预定义的顺序依次调用各个过滤器，直到最后一个过滤器完成处理。</li><li>身份验证是SpringSecurity中的一个重要功能，它能够验证请求的发起者是否具有访问受保护资源的权限，通常是通过用户名和密码来验证身份。在安全过滤器链中，如果存在身份验证相关的过滤器，则会自动进行身份验证操作，例如<strong>UsernamePasswordAuthenticationFilter</strong>。</li><li>如果请求通过了身份验证和授权操作，<strong>SpringSecurity</strong>会将请求转发给受保护资源，并返回相应的响应；否则，会返回相应的错误信息或者直接跳转登录页面。</li></ol><p><strong>SpringSecurity对于Servlet的支持是基于Servlet Filter的。也就是说SpringSecurity的实现技术手段也是Filter。</strong></p><h2 id="_4-回顾filter" tabindex="-1"><a class="header-anchor" href="#_4-回顾filter" aria-hidden="true">#</a> 4.回顾Filter</h2><h3 id="_4-1过滤器回顾" tabindex="-1"><a class="header-anchor" href="#_4-1过滤器回顾" aria-hidden="true">#</a> 4.1过滤器回顾</h3><p>SpringSecurity 的 Servlet 支持是基于 Servlet Filter 的，因此首先大致了解一下 <strong>Filter</strong> 的作用是有帮助的。下图显示了单个 <strong>HTTP请求</strong>的处理程序的典型分层。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311052223465.png" alt="image-20231105222301402" style="zoom:25%;"><p>客户端向应用程序发送请求，容器创建一个 <code>FilterChain</code> ，其中包含 <code>Filter</code> 实例和应处理 <code>HttpServletRequest</code> 是 <code>DispatcherServlet</code> 的实例。最多一个 <code>Servlet</code> 可以处理单个 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 。然而，多个 <code>Filter</code> 可用于：</p><ul><li>Prevent downstream <code>Filter</code> instances or the <code>Servlet</code> from being invoked. In this case, the <code>Filter</code> typically writes the <code>HttpServletResponse</code>.<br> 防止调用下游 <code>Filter</code> 实例或 <code>Servlet</code> 。在这种情况下， <code>Filter</code> 通常写入 <code>HttpServletResponse</code> 。</li><li>Modify the <code>HttpServletRequest</code> or <code>HttpServletResponse</code> used by the downstream <code>Filter</code> instances and the <code>Servlet</code>.<br> 修改下游 <code>Filter</code> 实例和 <code>Servlet</code> 使用的 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code> 。</li></ul><h3 id="_4-2过滤器核心" tabindex="-1"><a class="header-anchor" href="#_4-2过滤器核心" aria-hidden="true">#</a> 4.2过滤器核心</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// do something before the rest of the application</span>
    chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// invoke the rest of the application</span>
    <span class="token comment">// do something after the rest of the application</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 <code>Filter</code> 仅影响下游 <code>Filter</code> 实例和 <code>Servlet</code> ，因此调用每个 <code>Filter</code> 的顺序非常重要。</p><h2 id="_5-过滤器分类" tabindex="-1"><a class="header-anchor" href="#_5-过滤器分类" aria-hidden="true">#</a> 5.过滤器分类</h2><ol><li><strong>SecurityContextPersistenceFilter：</strong> 该过滤器用来确保在整个请求过程中**SecurityContext(安全上下文)**得以保留和传递。SecurityContext主要是用来存储当前用户的身份信息、角色、权限等。</li><li><strong>LogoutFilter：</strong> 该过滤器用来处理用户注销请求，通常会清除当前用户的身份信息。</li><li><strong>UsernamePasswordAuthenticationFilter：</strong> 该过滤器用来处理基于用户名和密码的身份认证请求。</li><li><strong>RequestCacheAwareFilter：</strong> 该过滤器用来缓存请求，以便后续重定向请求时可以正确地恢复请求状态。</li><li><strong>ExceptionTranslationFilter：</strong> 该过滤器用来处理由AccessDeniedHandler和AuthenticationEntryPoint抛出的异常，将它们转化为合适的HTTP响应。</li><li><strong>FilterSecurityInterceptor：</strong> 该过滤器用来进行授权操作，决定是否允许用户访问受保护资源。</li></ol><h2 id="_6-参考文献" tabindex="-1"><a class="header-anchor" href="#_6-参考文献" aria-hidden="true">#</a> 6.参考文献</h2>`,25),p={href:"https://docs.spring.io/spring-security/reference/servlet/architecture.html",target:"_blank",rel:"noopener noreferrer"},h=e("h2",{id:"_7-总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_7-总结","aria-hidden":"true"},"#"),t(" 7.总结")],-1),u=e("p",null,[t("以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是"),e("strong",null,"Leo"),t("，一个在互联网行业的小白，立志成为更好的自己。")],-1),g=e("p",null,[t("如果你想了解更多关于"),e("strong",null,"Leo"),t("，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。")],-1),m=e("figure",null,[e("img",{src:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202311301345907.png",alt:"公众号封面",tabindex:"0",loading:"lazy"}),e("figcaption",null,"公众号封面")],-1);function v(S,f){const n=a("ExternalLinkIcon");return i(),o("div",null,[d,e("ul",null,[e("li",null,[e("a",p,[t("https://docs.spring.io/spring-security/reference/servlet/architecture.html"),r(n)])])]),h,u,g,m])}const k=s(l,[["render",v],["__file","springsecurity6-filter.html.vue"]]);export{k as default};
