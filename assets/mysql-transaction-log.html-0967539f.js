import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as l,a as e,b as i,d as s,e as c}from"./app-8d307529.js";const g={},r={class:"hint-container tip"},t=e("p",{class:"hint-container-title"},"友情提示",-1),u=e("strong",null,"转载须知",-1),m={href:"https://www.bilibili.com/video/BV1iq4y1u7vj?p=1&vd_source=cea816a08805c218ac4390ae9b61ae31",target:"_blank",rel:"noopener noreferrer"},p=c(`<p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由 <code>锁机制</code> 实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。 <ul><li>REDO LOG 称为 <code>重做日志 </code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种 <code>恢复操作</code>，但是：</p><ul><li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了&#39;zzz&#39;数据。主要为了保证数据的可靠性。</li><li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是 <code>逻辑操作</code> 日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于 <code>事务的回滚</code> (undo log 记录的是每个修改操作的 <code>逆操作</code>) 和 <code>一致性非锁定读</code> (undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><h2 id="_1-redo日志" tabindex="-1"><a class="header-anchor" href="#_1-redo日志" aria-hidden="true">#</a> 1. redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。所有的变更都必须<code>先更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘 (<code>checkPoint</code>机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="_1-1-为什么需要redo日志" tabindex="-1"><a class="header-anchor" href="#_1-1-为什么需要redo日志" aria-hidden="true">#</a> 1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发</code> 的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题:</p><ul><li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</p></li><li><p><strong>随机IO刷新较慢</strong></p><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p><code>另一个解决的思路</code> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2</p><p>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710202517977.png" alt="image-20220710202517977" tabindex="0" loading="lazy"><figcaption>image-20220710202517977</figcaption></figure><h3 id="_1-2-redo日志的好处、特点" tabindex="-1"><a class="header-anchor" href="#_1-2-redo日志的好处、特点" aria-hidden="true">#</a> 1.2 REDO日志的好处、特点</h3><h4 id="_1-好处" tabindex="-1"><a class="header-anchor" href="#_1-好处" aria-hidden="true">#</a> 1. 好处</h4><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><h4 id="_2-特点" tabindex="-1"><a class="header-anchor" href="#_2-特点" aria-hidden="true">#</a> 2. 特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h3 id="_1-3-redo的组成" tabindex="-1"><a class="header-anchor" href="#_1-3-redo的组成" aria-hidden="true">#</a> 1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的 <code>连续内存</code> 空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710204114543.png" alt="image-20220710204114543" tabindex="0" loading="lazy"><figcaption>image-20220710204114543</figcaption></figure><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认 <code>16M</code> ，最大值是4096M，最小值为1M。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;%innodb_log_buffer_size%&#39;;
+------------------------+----------+
| Variable_name          | Value    |
+------------------------+----------+
| innodb_log_buffer_size | 16777216 |
+------------------------+----------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>重做日志文件 (redo log file) </code>，保存在硬盘中，是持久的。</li></ul><p>REDO日志文件如图所示，其中<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710204427616.png" alt="image-20220710204427616" tabindex="0" loading="lazy"><figcaption>image-20220710204427616</figcaption></figure><h3 id="_1-4-redo的整体流程" tabindex="-1"><a class="header-anchor" href="#_1-4-redo的整体流程" aria-hidden="true">#</a> 1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710204810264-16574572910841.png" alt="image-20220710204810264" tabindex="0" loading="lazy"><figcaption>image-20220710204810264</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值
第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式
第4步：定期将内存中修改的数据刷新到磁盘中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>体会： Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h3 id="_1-5-redo-log的刷盘策略" tabindex="-1"><a class="header-anchor" href="#_1-5-redo-log的刷盘策略" aria-hidden="true">#</a> 1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<code>一 定的频率</code>刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710205015302.png" alt="image-20220710205015302" tabindex="0" loading="lazy"><figcaption>image-20220710205015302</figcaption></figure><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 第4步：定期将内存中修改的数据刷新到磁盘中</li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</li></ul><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710205948156.png" alt="image-20220710205948156" style="float:left;"><p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把<code>redo log buffer</code>中的内容写到文件系统缓存(<code>page cache</code>)，然后调用刷盘操作。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210339724.png" alt="image-20220710210339724" tabindex="0" loading="lazy"><figcaption>image-20220710210339724</figcaption></figure><p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 <code>redo log buffer</code>中，这些redo log 记录会被<code>后台线程</code>刷盘。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210532805.png" alt="image-20220710210532805" tabindex="0" loading="lazy"><figcaption>image-20220710210532805</figcaption></figure><p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><h3 id="_1-6-不同刷盘策略演示" tabindex="-1"><a class="header-anchor" href="#_1-6-不同刷盘策略演示" aria-hidden="true">#</a> 1.6 不同刷盘策略演示</h3><h4 id="_1-流程图" tabindex="-1"><a class="header-anchor" href="#_1-流程图" aria-hidden="true">#</a> 1. 流程图</h4><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210751414.png" alt="image-20220710210751414" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710211318120.png" alt="image-20220710211318120" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710211335379.png" alt="image-20220710211335379" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710211618789.png" alt="image-20220710211618789" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710211831675.png" alt="image-20220710211831675" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710212041563.png" alt="image-20220710212041563" style="float:left;"><h4 id="_2-举例" tabindex="-1"><a class="header-anchor" href="#_2-举例" aria-hidden="true">#</a> 2. 举例</h4><p>比较innodb_flush_log_at_trx_commit对事务的影响。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE test_load(
a INT,
b CHAR(80)
)ENGINE=INNODB;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>DELIMITER//
CREATE PROCEDURE p_load(COUNT INT UNSIGNED)
BEGIN
DECLARE s INT UNSIGNED DEFAULT 1;
DECLARE c CHAR(80) DEFAULT REPEAT(&#39;a&#39;,80);
WHILE s&lt;=COUNT DO
INSERT INTO test_load SELECT NULL, c;
COMMIT;
SET s=s+1;
END WHILE;
END //
DELIMITER;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710215001482.png" alt="image-20220710215001482" style="float:left;"><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; CALL p_load(30000);
Query OK, 0 rows affected(1 min 23 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>1 min 23 sec</code>的时间显然是不能接受的。而造成时间比较长的原因就在于fsync操作所需要的时间。</p><p>修改参数innodb_flush_log_at_trx_commit，设置为0：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; set global innodb_flush_log_at_trx_commit = 0;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; CALL p_load(30000);
Query OK, 0 rows affected(38 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改参数innodb_flush_log_at_trx_commit，设置为2：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; set global innodb_flush_log_at_trx_commit = 2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; CALL p_load(30000);
Query OK, 0 rows affected(46 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710215353893.png" alt="image-20220710215353893" style="float:left;"><h3 id="_1-7-写入redo-log-buffer-过程" tabindex="-1"><a class="header-anchor" href="#_1-7-写入redo-log-buffer-过程" aria-hidden="true">#</a> 1.7 写入redo log buffer 过程</h3><h4 id="_1-补充概念-mini-transaction" tabindex="-1"><a class="header-anchor" href="#_1-补充概念-mini-transaction" aria-hidden="true">#</a> 1. 补充概念：Mini-Transaction</h4><p>MySQL把对底层页面中的一次原子访问过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组redo日志，在进行崩溃恢复时这一组<code>redo</code>日志可以作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710220653131.png" alt="image-20220710220653131" tabindex="0" loading="lazy"><figcaption>image-20220710220653131</figcaption></figure><h4 id="_2-redo-日志写入log-buffer" tabindex="-1"><a class="header-anchor" href="#_2-redo-日志写入log-buffer" aria-hidden="true">#</a> 2. redo 日志写入log buffer</h4><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710220838744.png" alt="image-20220710220838744" style="float:left;"><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710220919271.png" alt="image-20220710220919271" tabindex="0" loading="lazy"><figcaption>image-20220710220919271</figcaption></figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710221221981.png" alt="image-20220710221221981" style="float:left;"><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710221318271.png" alt="image-20220710221318271" tabindex="0" loading="lazy"><figcaption>image-20220710221318271</figcaption></figure><p>不同的事务可能是 <code>并发</code> 执行的，所以 T1 、 T2 之间的 mtr 可能是 <code>交替执行</code> 的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710221620291.png" alt="image-20220710221620291" tabindex="0" loading="lazy"><figcaption>image-20220710221620291</figcaption></figure><p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p><h4 id="_3-redo-log-block的结构图" tabindex="-1"><a class="header-anchor" href="#_3-redo-log-block的结构图" aria-hidden="true">#</a> 3. redo log block的结构图</h4><p>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8=492字节。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710223117420.png" alt="image-20220710223117420" style="float:left;"><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710223135374.png" alt="image-20220710223135374" tabindex="0" loading="lazy"><figcaption>image-20220710223135374</figcaption></figure><p>真正的redo日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓<code>管理信息</code>都有什么。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711144546439.png" alt="image-20220711144546439" tabindex="0" loading="lazy"><figcaption>image-20220711144546439</figcaption></figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711144608223.png" alt="image-20220711144608223" style="float:left;"><h3 id="_1-8-redo-log-file" tabindex="-1"><a class="header-anchor" href="#_1-8-redo-log-file" aria-hidden="true">#</a> 1.8 redo log file</h3><h4 id="_1-相关参数设置" tabindex="-1"><a class="header-anchor" href="#_1-相关参数设置" aria-hidden="true">#</a> 1. 相关参数设置</h4><ul><li><p><code>innodb_log_group_home_dir</code> ：指定 redo log 文件组所在的路径，默认值为 <code>./</code> ，表示在数据库 的数据目录下。MySQL的默认数据目录（ <code>var/lib/mysql</code>）下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1... iblogfilen。默认2个，最大100个。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;innodb_log_files_in_group&#39;;
+---------------------------+-------+
| Variable_name             | Value |
+---------------------------+-------+
| innodb_log_files_in_group | 2     |
+---------------------------+-------+
#ib_logfile0
#ib_logfile1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 <code>48M</code> 。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;innodb_log_file_size&#39;;
+----------------------+----------+
| Variable_name        | Value    |
+----------------------+----------+
| innodb_log_file_size | 50331648 |
+----------------------+----------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>[root@localhost ~]# vim /etc/my.cnf
innodb_log_file_size=200M
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</p></blockquote><h4 id="_2-日志文件组" tabindex="-1"><a class="header-anchor" href="#_2-日志文件组" aria-hidden="true">#</a> 2. 日志文件组</h4><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711152137012.png" alt="image-20220711152137012" style="float:left;"><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711152242300.png" alt="image-20220711152242300" tabindex="0" loading="lazy"><figcaption>image-20220711152242300</figcaption></figure><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group</code> 。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p><h4 id="_3-checkpoint" tabindex="-1"><a class="header-anchor" href="#_3-checkpoint" aria-hidden="true">#</a> 3. checkpoint</h4><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p><ul><li><code>write pos</code>是当前记录的位置，一边写一边后移</li><li><code>checkpoint</code>是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711152631108.png" alt="image-20220711152631108" style="zoom:80%;"><p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711152802294.png" alt="image-20220711152802294" style="zoom:80%;"><h3 id="_1-9-redo-log-小结" tabindex="-1"><a class="header-anchor" href="#_1-9-redo-log-小结" aria-hidden="true">#</a> 1.9 redo log 小结</h3><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711152930911.png" alt="image-20220711152930911" style="float:left;"><h2 id="_2-undo日志" tabindex="-1"><a class="header-anchor" href="#_2-undo日志" aria-hidden="true">#</a> 2. Undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 <code>更新数据</code> 的 <code>前置操作</code> 其实是要先写入一个 <code>undo log</code> 。</p><h3 id="_2-1-如何理解undo日志" tabindex="-1"><a class="header-anchor" href="#_2-1-如何理解undo日志" aria-hidden="true">#</a> 2.1 如何理解Undo日志</h3><p>事务需要保证 <code>原子性 </code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code> 服务器本身的错误</code> ， <code>操作系统错误</code> ，甚至是突然 <code>断电</code> 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code> ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 <code>原子性</code> 要求。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711153523704.png" alt="image-20220711153523704" style="float:left;"><h3 id="_2-2-undo日志的作用" tabindex="-1"><a class="header-anchor" href="#_2-2-undo日志的作用" aria-hidden="true">#</a> 2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711153645204.png" alt="image-20220711153645204" style="float:left;"><ul><li><strong>作用2：MVCC</strong></li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="_2-3-undo的存储结构" tabindex="-1"><a class="header-anchor" href="#_2-3-undo的存储结构" aria-hidden="true">#</a> 2.3 undo的存储结构</h3><h4 id="_1-回滚段与undo页" tabindex="-1"><a class="header-anchor" href="#_1-回滚段与undo页" aria-hidden="true">#</a> 1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code> ，而在每个undo log segment段中进行 <code>undo页</code> 的申请。</p><ul><li>在<code> InnoDB1.1版本之前</code> （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 <code>1024</code> 。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大 <code>128个rollback segment</code> ，故其支持同时在线的事务限制提高到 了 <code>128*1024</code> 。</li></ul><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;innodb_undo_logs&#39;;
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_undo_logs | 128   |
+------------------+-------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711154936382.png" alt="image-20220711154936382" style="float:left;"><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711155044078.png" alt="image-20220711155044078" style="float:left;"><h4 id="_2-回滚段与事务" tabindex="-1"><a class="header-anchor" href="#_2-回滚段与事务" aria-hidden="true">#</a> 2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数 据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; show variables like &#39;innodb_undo_tablespaces&#39;;
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| innodb_undo_tablespaces | 2     |
+-------------------------+-------+
# undo log的数量，最少为2. undo log的truncate操作有purge协调线程发起。在truncate某个undo log表空间的过程中，保证有一个可用的undo log可用。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><h4 id="_3-回滚段中的数据分类" tabindex="-1"><a class="header-anchor" href="#_3-回滚段中的数据分类" aria-hidden="true">#</a> 3. 回滚段中的数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据&quot;。</li></ol><p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断。</p><h3 id="_2-4-undo的类型" tabindex="-1"><a class="header-anchor" href="#_2-4-undo的类型" aria-hidden="true">#</a> 2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log</p><p>insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p></li><li><p>update undo log</p><p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><h3 id="_2-5-undo-log的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-5-undo-log的生命周期" aria-hidden="true">#</a> 2.5 undo log的生命周期</h3><h4 id="_1-简要生成过程" tabindex="-1"><a class="header-anchor" href="#_1-简要生成过程" aria-hidden="true">#</a> 1. 简要生成过程</h4><p>以下是undo+redo事务的简化过程</p><p>假设有两个数值，分别为A=1和B=2，然后将A修改为3，B修改为4</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711162414928.png" alt="image-20220711162414928" style="float:left;"><p><strong>只有Buffer Pool的流程：</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711162505008.png" alt="image-20220711162505008" tabindex="0" loading="lazy"><figcaption>image-20220711162505008</figcaption></figure><p><strong>有了Redo Log和Undo Log之后：</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711162642305.png" alt="image-20220711162642305" tabindex="0" loading="lazy"><figcaption>image-20220711162642305</figcaption></figure><p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p><h4 id="_2-详细生成过程" tabindex="-1"><a class="header-anchor" href="#_2-详细生成过程" aria-hidden="true">#</a> 2. 详细生成过程</h4><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711162919157.png" alt="image-20220711162919157" style="float:left;"><p><strong>当我们执行INSERT时：</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>begin;
INSERT INTO user (name) VALUES (&quot;tom&quot;);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值...，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711163725129.png" alt="image-20220711163725129" tabindex="0" loading="lazy"><figcaption>image-20220711163725129</figcaption></figure><p><strong>当我们执行UPDATE时：</strong></p><p>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，假设现在执行：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>UPDATE user SET name=&quot;Sun&quot; WHERE id=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711164138414.png" alt="image-20220711164138414" tabindex="0" loading="lazy"><figcaption>image-20220711164138414</figcaption></figure><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no=0）。</p><p>假设现在执行：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>UPDATE user SET id=2 WHERE id=1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711164421494.png" alt="image-20220711164421494" tabindex="0" loading="lazy"><figcaption>image-20220711164421494</figcaption></figure><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到我们的原始数据了。</p><h4 id="_3-undo-log是如何回滚的" tabindex="-1"><a class="header-anchor" href="#_3-undo-log是如何回滚的" aria-hidden="true">#</a> 3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除</li></ol><h4 id="_4-undo-log的删除" tabindex="-1"><a class="header-anchor" href="#_4-undo-log的删除" aria-hidden="true">#</a> 4. undo log的删除</h4><ul><li><p>针对于insert undo log</p><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>针对于update undo log</p><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><blockquote><p>补充：</p><p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清理page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种“假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p></blockquote><h3 id="_2-6-小结" tabindex="-1"><a class="header-anchor" href="#_2-6-小结" aria-hidden="true">#</a> 2.6 小结</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220711165612956.png" alt="image-20220711165612956" tabindex="0" loading="lazy"><figcaption>image-20220711165612956</figcaption></figure><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312031906036.png" alt="公众号封面" tabindex="0" loading="lazy"><figcaption>公众号封面</figcaption></figure>`,174);function h(f,b){const o=n("ExternalLinkIcon");return d(),l("div",null,[e("div",r,[t,e("p",null,[u,i(": 以下所有文章整理于B站宋红康老师的《MySQL数据库入门到大牛》。"),e("a",m,[i("MySQL"),s(o)])])]),p])}const y=a(g,[["render",h],["__file","mysql-transaction-log.html.vue"]]);export{y as default};
